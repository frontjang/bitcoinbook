[[ch06]]
[[거래]]
== 거래

[[ch06_intro]]
=== 소개

((("transactions", "defined")))((("warnings and cautions", see="also security")))트랜잭션은 비트 코인 시스템에서 가장 중요한 부분입니다. ((( "transactions", "defined")))) (( "경고 및주의", = "also security" Bitcoin의 다른 모든 기능은 트랜잭션을 생성하고, 네트워크에 전파하고, 유효성을 검사하고, 트랜잭션의 글로벌 원장 (블록 체인)에 트랜잭션을 추가 할 수 있도록 설계되었습니다. 트랜잭션은 비트 동전 시스템의 참가자간에 가치 이동을 인코딩하는 데이터 구조입니다. 각 거래는 비트 코인의 블록 체인 (bitcoin 's blockchain)의 글로벌 이중 입력 부기 장부에 공개됩니다.

이 장에서는 다양한 형태의 트랜잭션, 트랜잭션의 내용, 트랜잭션의 생성 방법, 트랜잭션의 검증 방법 및 모든 트랜잭션에 대한 영구 레코드의 일부를 살펴 봅니다. 이 장에서 "지갑"이라는 용어를 사용할 때는 키 데이터베이스 만이 아니라 트랜잭션을 구성하는 소프트웨어를 언급합니다.

[[tx_structure]]
=== 세부 거래

((("use cases", "buying coffee", id="alicesix")))<< ch02_bitcoin_overview >>에서는 Bob의 다방에서 앨리스가 커피 대금을 지불하기 위해 사용했던 거래를 차단 탐색기 (<< ( "유스 케이스", "구매 사례", id = "alicesix")) alices_transactions_to_bobs_cafe >>).

블록 탐색기 응용 프로그램은 Alice의 "주소"에서 Bob의 "주소"로의 트랜잭션을 보여줍니다. 이것은 트랜잭션에 포함 된 내용을 훨씬 단순하게 보여줍니다. 사실,이 장에서 볼 수 있듯이 표시된 많은 정보는 블록 탐색기에 의해 생성되며 실제로 트랜잭션에 포함되지 않습니다.

[[alices_transactions_to_bobs_cafe]]
.Alice's transaction to Bob's Cafe
image::images/mbc2_0208.png["Alice Coffee Transaction"]

[[transactions_behind_the_scenes]]
==== Transactions&#x2014;Behind the Scenes

((("transactions", "behind the scenes details of")))실제 트랜잭션은 일반적인 블록 탐색기에서 제공하는 트랜잭션과 매우 다르게 보입니다. 사실, 다양한 비트 코인 애플리케이션 사용자 인터페이스에서 볼 수있는 대부분의 고급 구조는 비트 코인 시스템에 실제로 존재하지 않습니다.

Bitcoin Core의 명령 줄 인터페이스 (+ getrawtransaction + 및 + decoderawtransaction +)를 사용하여 Alice의 "원시"트랜잭션을 검색하고 디코드하고 포함 된 내용을 볼 수 있습니다. 결과는 다음과 같습니다.

[[alice_tx]]
.Alice's transaction decoded
[source,json]
----
{
  "version": 1,
  "locktime": 0,
  "vin": [
    {
      "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
      "vout": 0,
      "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
      "sequence": 4294967295
    }
  ],
  "vout": [
    {
      "value": 0.01500000,
      "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG"
    },
    {
      "value": 0.08450000,
      "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
    }
  ]
}
----

이 트랜잭션에 대한 몇 가지 사항, 주로 누락 된 사항을 확인할 수 있습니다! 앨리스의 주소는 어디에 있습니까? 밥의 주소는 어디 있니? Alice가 0.1 입력을 "보낸"곳은 어디입니까? 비트 코인에는 동전, 송금인, 수령인, 잔액 없음, 계좌 없음 및 주소가 없습니다. 모든 것들은 이해하기 쉽게하기 위해 사용자의 이익을 위해 더 높은 수준에서 구성됩니다.

또한 이상하고 해독 할 수없는 필드와 16 진수 문자열을 많이 볼 수 있습니다. 걱정하지 마십시오. 여기에 표시된 각 필드는이 장에서 자세히 설명 할 것입니다.

[[tx_inputs_outputs]]
=== 트랜잭션 출력과 입력

((("transactions", "outputs and inputs", id="Tout06")))((("outputs and inputs", "outputs defined")))((("unspent transaction outputs (UTXO)")))((("UTXO sets")))((("transactions", "outputs and inputs", "output characteristics")))((("outputs and inputs", "output characteristics")))비트 코인 트랜잭션의 블록은 _ 트랜잭션 (transaction) 출력 _입니다. 트랜잭션 출력은 블록 체인에 기록 된 비트 코인 통화의 불가분 한 덩어리이며 전체 네트워크에서 유효한 것으로 인식됩니다. Bitcoin 전체 노드는 _unspent transaction outputs_ 또는 _UTXO_라고하는 사용 가능하고 소비 가능한 모든 출력을 추적합니다. 모든 UTXO의 수집은 _UTXO set_로 알려져 있으며 현재 UTXO의 수백만 개에 해당합니다. 새로운 UTXO가 생성되면 UTXO 세트가 커지고 UTXO가 소비되면 축소됩니다. 모든 트랜잭션은 UTXO 집합에서 변경 (상태 전이)을 나타냅니다.

((("balances")))사용자의 지갑에 비트 동전이 "수신"되었다고 말하면 지갑이 해당 지갑이 제어하는 ​​키 중 하나를 소비 할 수있는 UTXO가 있음을 의미합니다. 따라서 사용자의 비트 코인 "잔액"은 사용자의 지갑이 소비 할 수있는 모든 UTXO의 합계이며 수백 개의 트랜잭션과 수백 개의 블록 사이에 흩어져있을 수 있습니다. 저울 개념은 지갑 응용 프로그램에서 만듭니다. 지갑은 블록 체인을 스캔하고 지갑이 소비하는 UTXO의 가치를 자신이 제어하는 ​​키와 통합하여 사용자의 잔고를 계산합니다. 대부분의 지갑은 데이터베이스를 유지 관리하거나 데이터베이스 서비스를 사용하여 제어하는 ​​키로 보낼 수있는 모든 UTXO의 빠른 참조 집합을 저장합니다.

((("satoshis")))트랜잭션 출력은 사오 시스의 배수로 표시된 임의의 (정수) 값을 가질 수 있습니다. 달러가 센트로 두 자릿수로 나눌 수있는 것처럼, 비트 코틴은 사오 시스로 8 자릿수로 나눌 수 있습니다. 출력은 임의의 값을 가질 수 있지만 일단 생성되면 분할 할 수 없습니다. 이것은 강조 할 필요가있는 산출물의 중요한 특성입니다. 산출물은 정수 값으로 표시되는 값의 _discrete_ 및 _indivisible_ 단위입니다. 소비되지 않은 출력은 트랜잭션에 의해서만 완전히 소모 될 수 있습니다.

((("change, making")))UTXO가 원하는 트랜잭션 값보다 큰 경우, UTXO가 전체적으로 소비되어야하고 변경이 트랜잭션에서 생성되어야합니다. 즉, UTXO가 20 비트 코코 (bitcoin) 인 경우 비트 코인을 1 개만 지불하려는 경우 트랜잭션은 전체 20 비트 코코 UTXO를 소비하고 두 개의 출력을 생성해야합니다. 하나는 원하는 수신자에게 1 비트 코치를 지불하고 다른 하나는 19 비트 코코인을 변경합니다 다시 지갑에. 트랜잭션 출력의 불가분의 특성으로 인해 대부분의 비트 코 인 트랜잭션은 변경을 생성해야합니다.

구매자가 1.50 달러의 음료를 사서 상금에 도달하고 1.50 달러의 비용을 충당하기 위해 동전과 지폐의 조합을 찾으려한다고 상상해보십시오. 구매자는 가능한 경우 정확한 변경 (예 : 달러 지폐 및 2/4) 또는 더 작은 금액 (6/4)의 조합을 선택하거나 필요한 경우 5 달러 지폐와 같은 더 큰 단위를 선택합니다. 그녀가 5 달러라고 말하면서 상점 주인에게 너무 많은 돈을 건네면, 그녀는 지갑에 돌아가서 미래의 거래에 사용할 수있는 $ 3.50의 변경을 기대할 것입니다.

마찬가지로 사용자가 사용할 수있는 모든 단위로 비트 코인 트랜잭션을 사용자의 UTXO에서 만들어야합니다. 사용자는 UTXO를 절반으로 줄이거 나 할 수 없으며, 달러짜리 지폐를 반으로 자르고 통화로 사용할 수 있습니다. 사용자의 지갑 응용 프로그램은 일반적으로 사용자가 사용할 수있는 UTXO를 선택하여 원하는 거래 금액보다 크거나 같은 금액을 구성합니다.

실생활과 마찬가지로, 비트 코인 애플리케이션은 몇 개의 작은 단위를 결합하거나, 정확한 변경을 찾거나, 트랜잭션 값보다 큰 단일 단위를 사용하여 변경하는 등 구입량을 만족시키는 여러 가지 전략을 사용할 수 있습니다. 이 복잡한 UTXO의 복잡한 어셈블리는 모두 사용자의 지갑에서 자동으로 수행되며 사용자에게는 보이지 않습니다. UTXO에서 원시 트랜잭션을 프로그래밍 방식으로 생성하는 경우에만 관련이 있습니다.

트랜잭션은 이전에 기록 된 미사용 트랜잭션 출력을 소비하고 향후 트랜잭션이 소비 할 수있는 새로운 트랜잭션 출력을 생성합니다. 이렇게하면 UTXO를 소비하고 생성하는 일련의 트랜잭션에서 비트 코인 값의 덩어리가 소유자에서 소유자로 이동합니다.

((("transactions", "coinbase transactions")))((("coinbase transactions")))((("mining and consensus", "coinbase transactions")))출력 및 입력 사슬에 대한 예외는 다음과 같다. (( "("거래 ","코인베이스 거래 "))) 각 블록의 첫 번째 트랜잭션 인 _coinbase_ transaction이라는 특별한 유형의 트랜잭션. 이 거래는 "승리 한"광부에 의해 이루어지며 광산에 대한 보상으로 해당 광부에게 지불 할 수있는 새로운 비트 코인을 생성합니다. 이 특별한 코인베이스 트랜잭션은 UTXO를 소비하지 않습니다. 대신에 "coinbase"라는 특별한 유형의 입력이 있습니다. 이것이 << 광산 >>에서 볼 수 있듯이 비트 코인의 돈 공급이 광업 과정에서 어떻게 생성되는지를 보여줍니다.

[팁]
====
무엇이 먼저 오나요? 입력 또는 출력, 닭고기 또는 계란? 엄밀히 말하면 새로운 비트 코인을 생성하는 코인베이스 트랜잭션에는 입력이없고 아무 것도 출력하지 않기 때문에 출력이 먼저 발생합니다.
====

[[tx_outs]]
==== 트랜잭션 출력

((("transactions", "outputs and inputs", "output components")))((("outputs and inputs", "output parts")))모든 비트 동전 트랜잭션은 비트 동전 장장에 기록되는 출력을 생성합니다. 하나의 예외 (<< op_return >> 참조)를 제외하고는 거의 모든 출력이 UTXO라는 비트 동전 덩어리를 생성합니다. UTXO는 전체 네트워크에서 인식되며 소유자가 향후 트랜잭션에 사용할 수 있습니다.

UTXO는 UTXO 세트의 모든 전체 노드 비트 코 클라이언트에 의해 추적됩니다. 새 트랜잭션은 UTXO 집합의 이러한 출력 중 하나 이상을 소비합니다.

트랜잭션 출력은 두 부분으로 구성됩니다.

* 비트 코인 (bitcoin), 가장 작은 비트 코 단위 인 _satoshis_에 명명 됨
* 출력을 소비하는 데 필요한 조건을 결정하는 암호화 퍼즐

((("locking scripts")))((("scripting", "locking scripts")))((("witnesses")))((("scriptPubKey")))암호화 퍼즐은 다음과 같이 알려져 있습니다. ((( "locking scripts"))) (( "scripting", "locking scripts"))) _locking script_, _ _itness _ script_ 또는 + scriptPubKey +입니다.

앞에서 언급 한 잠금 스크립트에서 사용되는 트랜잭션 스크립팅 언어는 << tx_script >>에서 자세히 설명합니다.

앨리스의 트랜잭션 (이전에 << transactions_behind_the_scenes >>에 표시)을 살펴보고 출력을 식별 할 수 있는지 확인해 봅시다. JSON 인코딩에서 출력은 + vout +라는 배열 (목록)에 있습니다.

[source,json]
----
"vout": [
  {
    "value": 0.01500000,
    "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY
    OP_CHECKSIG"
  },
  {
    "value": 0.08450000,
    "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
  }
]
----

보시다시피 거래에는 두 개의 출력이 포함되어 있습니다. 각 출력은 값과 암호 퍼즐로 정의됩니다. Bitcoin Core에 표시된 인코딩에서 값은 비트 코인으로 표시되지만 트랜잭션 자체에서는 사오 시스로 표시된 정수로 기록됩니다. 각 출력의 두 번째 부분은 지출 조건을 설정하는 암호화 퍼즐입니다. Bitcoin Core는 이것을 + scriptPubKey +로 표시하고 사람이 읽을 수있는 스크립트를 보여줍니다.

UTXO 잠금 및 잠금 해제에 대한 주제는 나중에 "tx_lock_unlock"에서 설명합니다. + scriptPubKey +에서 스크립트에 사용되는 스크립팅 언어는 << tx_script >>에서 설명합니다. 그러나 이러한 주제를 탐구하기 전에 트랜잭션 입력 및 출력의 전반적인 구조를 이해해야합니다.

===== 트랜잭션 직렬화 & # x2014;

((("transactions", "outputs and inputs", "structure of")))((("outputs and inputs", "structure of")))((("serialization", "outputs")))트랜잭션이 네트워크를 통해 전송되거나 응용 프로그램간에 교환되면 _ 직렬화됩니다. 직렬화는 데이터 구조의 내부 표현을 한 번에 한 바이트 씩 전송할 수있는 형식 (바이트 스트림이라고도 함)으로 변환하는 프로세스입니다. 직렬화는 네트워크를 통한 전송 또는 파일의 저장을 위해 데이터 구조를 인코딩하는 데 가장 일반적으로 사용됩니다. 트랜잭션 출력의 직렬화 형식은 << tx_out_structure >>에 표시됩니다.

[[tx_out_structure]]
.Transaction output serialization
[options="header"]
|=======
|Size| Field | Description
| 8 bytes (little-endian) | Amount  | Bitcoin value in satoshis (10^-8^ bitcoin)
| 1&#x2013;9 bytes (VarInt) | Locking-Script Size | Locking-Script length in bytes, to follow
| Variable | Locking-Script | A script defining the conditions needed to spend the output
|=======

대부분의 비트 동전 라이브러리와 프레임 워크는 트랜잭션을 내부적으로 바이트 스트림으로 저장하지 않으므로 단일 필드에 액세스해야 할 때마다 복잡한 구문 분석이 필요합니다. 편의성과 가독성을 위해 bitcoin 라이브러리는 트랜잭션을 내부적으로 데이터 구조 (일반적으로 객체 지향 구조)에 저장합니다.

((("deserialization")))((("parsing")))((("transactions", "parsing")))트랜잭션의 바이트 스트림 표현을 라이브러리의 내부 표현 데이터로 변환하는 프로세스 (( "(" "역 직렬화))) 구조를 _deserialization_ 또는 _transaction parsing_이라고합니다. 네트워크를 통한 전송, 해시 또는 디스크의 저장을 위해 바이트 스트림으로 다시 변환하는 프로세스를 _ 직렬화라고합니다. 대부분의 비트 동전 라이브러리에는 트랜잭션 직렬화 및 비 직렬화를위한 내장 함수가 있습니다.

직렬화 된 16 진수 형식에서 앨리스의 트랜잭션을 수동으로 디코딩 할 수 있는지 확인하고 이전에 본 요소 중 일부를 찾아보십시오. 두 출력을 포함하는 섹션은 << example_6_1 >>에 강조 표시되어 있습니다.

[[example_6_1]]
.Alice's transaction, serialized and presented in hexadecimal notation
====
+0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73+
+4d2804fe65fa35779000000008b483045022100884d142d86652a3f47+
+ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039+
+ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813+
+01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84+
+16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1+
+7b4a10fa336a8d752adfffffffff02+*+60e31600000000001976a914ab6+*
*+8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000+*
*+1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac+*
+00000000+
====

여기에 몇 가지 힌트가 있습니다 :

* 강조 표시된 섹션에는 두 개의 출력이 있으며, 각각은 << tx_out_structure >>에 표시된대로 일련 화됩니다.
* 0.015 bitcoin의 값은 1,500,000 satoshis입니다. 16 진수로 +16 e3 60+입니다.
직렬화 된 트랜잭션에서 값 +16 e3 60+는 리틀 엔디안 (최하위 바이트 우선) 바이트 순서로 인코딩되므로 +60 e3 16+처럼 보입니다.
* + scriptPubKey + 길이는 25 바이트이며 16 진수로 +19+입니다.

[[tx_inputs]]
==== 거래 입력

((("transactions", "outputs and inputs", "input components")))((("outputs and inputs", "input components")))((("unspent transaction outputs (UTXO)")))((("UTXO sets")))트랜잭션 입력은 UTXO가 사용되는지 확인하고 (참조로) 잠금 해제 스크립트를 통해 소유권 증명을 제공합니다.

트랜잭션을 구축하기 위해 지갑은 UTXO에서 제어하며, UTXO는 충분한 금액으로 요청 된 지불을 수행합니다. 때로는 하나의 UTXO 만 있으면 충분하고, 다른 경우는 하나 이상 필요합니다. 이 지불에 소비되는 각 UTXO에 대해 지갑은 UTXO를 가리키는 하나의 입력을 생성하고 잠금 해제 스크립트로 잠금을 해제합니다.

입력 요소를 더 자세히 살펴 보겠습니다. 입력의 첫 번째 부분은 UTXO가 블록 체인에 기록되는 트랜잭션 해시 및 시퀀스 번호를 참조하여 UTXO에 대한 포인터입니다. 두 번째 부분은 UTXO에 설정된 지출 조건을 충족시키기 위해 지갑이 구성하는 잠금 해제 스크립트입니다. 대부분의 경우 잠금 해제 스크립트는 비트 코인의 소유권을 증명하는 디지털 서명 및 공개 키입니다. 그러나 모든 잠금 해제 스크립트가 서명을 포함하는 것은 아닙니다. 세 번째 부분은 시퀀스 번호입니다.이 번호는 나중에 설명합니다.

<< transactions_behind_the_scenes >>의 예제를 고려하십시오. 트랜잭션 입력은 + vin +라고하는 배열 (목록)입니다.

[[vin]]
.The transaction inputs in Alice's transaction
[source,json]
----
"vin": [
  {
    "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
    "vout": 0,
    "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
    "sequence": 4294967295
  }
]
----

보시다시피 목록에 하나의 입력 만 있습니다 (하나의 UTXO에 충분한 금액이 포함되어 있기 때문에). 입력에는 네 가지 요소가 포함됩니다.

* A ((( "트랜잭션 ID (txd)"))) 트랜잭션 ID, 사용중인 UTXO를 포함하는 트랜잭션 참조
* 해당 트랜잭션에서 UTXO를 참조하는 출력 인덱스 (+ vout +) (첫 번째 인덱스는 0 임)
* A + scriptSig +, UTXO에 배치 된 조건을 충족하여 지출을 위해 잠금 해제
* 일련 번호 (나중에 설명 함)

Alice의 트랜잭션에서 입력은 트랜잭션 ID를 가리 킵니다.

----
7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18
----

인덱스 +0+ (즉, 그 트랜잭션에 의해 생성 된 첫 번째 UTXO)를 출력한다. 잠금 해제 스크립트는 Alice의 지갑에서 먼저 참조 된 UTXO를 검색하고 잠금 스크립트를 검사 한 다음 잠금 스크립트를 사용하여이를 충족시키는 데 필요한 잠금 해제 스크립트를 작성합니다.

입력을 보았을 때 우리는이 UTXO를 포함하고있는 트랜잭션에 대한 참조 이외에이 UTXO에 대해 알지 못했음을 눈치 챘을 것입니다. 우리는 그 값 (satoshi의 양)을 알지 못하며 그것을 보내기위한 조건을 설정하는 잠금 스크립트를 모른다. 이 정보를 찾으려면 기본 트랜잭션을 검색하여 참조 된 UTXO를 검색해야합니다. 입력 값이 명시 적으로 명시되어 있지 않으므로이 트랜잭션에서 지불 할 수수료를 계산하려면 참조 된 UTXO를 사용해야합니다 (<< tx_fees >> 참조).

입력에서 참조 된 UTXO를 검색해야하는 것은 Alice의 지갑이 아닙니다. 이 트랜잭션이 네트워크에 브로드 캐스팅되면 모든 유효성을 검사하는 노드는 트랜잭션의 유효성을 검사하기 위해 트랜잭션 입력에서 참조되는 UTXO를 검색해야합니다.

컨텍스트가 없기 때문에 자체적 인 트랜잭션은 불완전한 것처럼 보입니다. 그들은 입력에서 UTXO를 참조하지만 UTXO를 검색하지 않고 입력 값이나 잠금 조건의 값을 알 수 없습니다. 비트 코인 소프트웨어를 작성할 때 트랜잭션의 유효성을 확인하거나 수수료를 계산하거나 잠금 해제 스크립트를 검사 할 때마다 코드는 우선 암시 적으로 존재하지만 존재하지 않는 컨텍스트를 구축하기 위해 먼저 블록 체인에서 참조 된 UTXO를 검색해야합니다 입력의 UTXO 참조. 예를 들어, 수수료로 지불 한 금액을 계산하려면 입력 값과 출력 값의 합계를 알아야합니다. 그러나 입력에서 참조 된 UTXO를 검색하지 않으면 그 값을 알 수 없습니다. 따라서 단일 거래에서 수수료를 계산하는 것처럼 보이는 단순한 작업은 사실 여러 거래의 여러 단계와 데이터를 포함합니다.

Alice의 트랜잭션 (+ getrawtransaction + 및 + decoderawtransaction +)을 검색 할 때 사용한 것과 동일한 명령 시퀀스를 Bitcoin Core와 함께 사용할 수 있습니다. 이를 통해 이전 입력에서 참조 된 UTXO를 가져 와서 살펴볼 수 있습니다.

[[alice_input_tx]]
.Alice's UTXO from the previous transaction, referenced in the input
[source,json]
----
"vout": [
   {
     "value": 0.10000000,
     "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG"
   }
 ]
----

이 UTXO의 값은 0.1BTC이며 "OP_DUP OP_HASH160 ..."을 포함하는 잠금 스크립트 (+ scriptPubKey +)가 있음을 알 수 있습니다.

[팁]
====
앨리스의 트랜잭션을 완전히 이해하기 위해 입력으로 참조 된 이전 트랜잭션을 검색해야했습니다. 이전 트랜잭션 및 사용하지 않는 트랜잭션 출력을 검색하는 함수는 매우 일반적이며 거의 모든 비트 코인 라이브러리 및 API에 있습니다.
====

===== 트랜잭션 직렬화 & # x2014; 입력

((("serialization", "inputs")))((("transactions", "outputs and inputs", "input serialization")))((("outputs and inputs", "input serialization")))트랜잭션은 네트워크에서 전송을 위해 직렬화되며, 해당 입력은 << tx_in_structure >>에 표시된 것처럼 바이트 스트림으로 인코딩됩니다.

[[tx_in_structure]]
.Transaction input serialization
[options="header"]
|=======
|Size| Field | Description
| 32 bytes | Transaction Hash | Pointer to the transaction containing the UTXO to be spent
| 4 bytes | Output Index | The index number of the UTXO to be spent; first one is 0
| 1&#x2013;9 bytes (VarInt) | Unlocking-Script Size | Unlocking-Script length in bytes, to follow
| Variable | Unlocking-Script | A script that fulfills the conditions of the UTXO locking script
| 4 bytes | Sequence Number | Used for locktime or disabled (0xFFFFFFFF)
|=======

출력과 마찬가지로 Alice의 트랜잭션에서 입력을 직렬화 된 형식으로 찾을 수 있는지 살펴 보겠습니다. 첫째, 디코딩 된 입력 :

[source,json]
----
"vin": [
  {
    "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
    "vout": 0,
    "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
    "sequence": 4294967295
  }
],
----

<< example_6_2 >>의 직렬화 된 16 진수 인코딩에서이 필드를 식별 할 수 있는지 확인해 봅시다.

[[example_6_2]]
.Alice의 트랜잭션, 16 진법으로 직렬화되고 표현됨.
====
+0100000001+*+186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73+*
*+4d2804fe65fa35779000000008b483045022100884d142d86652a3f47+*
*+ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039+*
*+ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813+*
*+01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84+*
*+16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1+*
*+7b4a10fa336a8d752adfffffffff+*+0260e31600000000001976a914ab6+
+8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000+
+1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac00000+
+000+
====

힌트 :

* 트랜잭션 ID는 역순으로 바이트 순서로 직렬화되므로 (16 진수) +18+로 시작하고 +79+로 끝납니다
* 출력 색인은 쉽게 식별 할 수있는 4 바이트의 0 그룹입니다.
* + scriptSig +의 길이는 139 바이트 또는 16 진수 + 8b +입니다.
* 시퀀스 번호는 + FFFFFFFF +로 설정되어 다시 식별하기 쉽습니다 (( "" ", startref ="alicesix ")))

[[tx_fees]]
==== 거래 수수료

((("transactions", "outputs and inputs", "transaction fees")))((("fees", "transaction fees")))((("mining and consensus", "rewards and fees")))대부분의 거래에는 거래 수수료가 포함되어있어 비트 코 광부가 네트워크 보안을 보완합니다. 또한 요금은 공격자가 네트워크를 트랜잭션으로 넘치게하는 것이 경제적으로 불가능하기 때문에 보안 메커니즘의 역할을합니다. 광업과 광부가 수집 한 보수 및 보상은 << 채광 >>에서보다 자세히 논의됩니다.

이 섹션에서는 일반적인 거래에서 거래 수수료가 어떻게 포함되는지 검토합니다. 대부분의 지갑은 거래 수수료를 자동으로 계산하여 포함합니다. 그러나 프로그래밍 방식으로 트랜잭션을 구성하거나 명령 줄 인터페이스를 사용하는 경우 이러한 수수료를 수동으로 계산하여 포함시켜야합니다.

거래 수수료는 다음 블록에 거래를 포함 시키거나 모든 거래에 작은 비용을 부과함으로써 시스템 남용을 저지하는 인센티브로 작용합니다. 거래 수수료는 블록 체인에 거래를 기록하는 블록을 채굴하는 광부가 수집합니다.

거래 수수료는 비트 코인 (bitcoin) 거래의 가치가 아닌 킬로바이트 단위의 거래 규모를 기반으로 계산됩니다. 전체적으로 거래 수수료는 비트 코인 네트워크 내의 시장 세력을 기반으로 설정됩니다. 광부는 수수료를 포함한 다양한 기준에 따라 거래의 우선 순위를 정하고 특정 상황에서 무료로 거래를 처리 할 수도 있습니다. 거래 수수료는 처리 우선 순위에 영향을 미치므로 충분한 수수료가있는 거래가 채굴 된 다음 블록에 포함될 수있는 반면 수수료가 충분하지 않거나 전혀없는 거래는 지연되거나 몇 블록 후에 최선 조치로 처리되거나 전혀 처리되지 않았습니다. 거래 수수료는 의무 사항은 아니며 수수료없는 거래는 결국 처리 될 수 있습니다. 그러나 거래 수수료를 포함하여 우선 처리가 권장됩니다.

시간이 지남에 따라 거래 수수료가 계산되고 거래 우선 순위에 미치는 영향이 진화되었습니다. 처음에는 거래 수수료가 네트워크 전체에서 고정되어 일정했습니다. 점차적으로 수수료 구조는 완화되었으며 네트워크 용량 및 거래량에 따라 시장 세력의 영향을받을 수 있습니다. 적어도 2016 년 초부터 비트 코인의 용량 제한으로 인해 거래가 서로 경쟁하여 수수료가 인상되고 무료 거래가 효과적으로 이루어졌습니다. 0 수수료 또는 매우 낮은 수수료 거래는 거의 채굴되지 않으며 때로는 네트워크를 통해 전파되지 않습니다.

((("fees", "fee relay policies")))((("minrelaytxfee option")))Bitcoin Core에서 요금 릴레이 정책은 + minrelaytxfee + 옵션으로 설정됩니다. 현재 기본값 + minrelaytxfee +는 0.00001 비트 코인 또는 킬로바이트 당 100 분의 1 밀리비트 동전입니다. 따라서 기본적으로 0.0001 비트 동전 미만의 수수료는 무료로 취급되며 mempool에 공간이있는 경우에만 릴레이됩니다. 그렇지 않으면 삭제됩니다. Bitcoin 노드는 + minrelaytxfee + 값을 조정하여 기본 요금 릴레이 정책을 무시할 수 있습니다.

((("dynamic fees")))((("fees", "dynamic fees")))지갑, 교환, 소매 응용 프로그램 등 트랜잭션을 생성하는 비트 코인 서비스는 반드시 동적 요금을 구현해야합니다. 동적 요금은 제 3 자 요금 견적 서비스 또는 내장 요금 산정 알고리즘을 통해 구현할 수 있습니다. 확실하지 않은 경우 제 3 자 서비스를 시작하고 타사 종속성을 제거하려는 경우 경험을 쌓고 자신의 알고리즘을 구현하십시오.

수수료 산정 알고리즘은 "경쟁"거래에서 제공되는 용량 및 수수료를 기준으로 적절한 요금을 계산합니다. 이 알고리즘은 단순한 (마지막 블록의 평균 또는 중간 비용)부터 정교한 (통계 분석)까지 다양합니다. 이들은 트랜잭션을 선택하고 특정 수의 블록 내에 포함시킬 가능성이 높은 (블록 당 바이트 단위로) 필요한 요금을 계산합니다. 대부분의 서비스는 높음, 중간 또는 낮은 우선 순위 요금을 선택할 수있는 옵션을 사용자에게 제공합니다. 높은 우선 순위는 사용자가 높은 수수료를 지불하지만 거래가 다음 블록에 포함될 가능성이 높음을 의미합니다. 중간 및 낮은 우선 순위는 사용자가 낮은 거래 수수료를 지불하지만 거래가 확인하는 데 훨씬 오래 걸릴 수 있음을 의미합니다.

((("bitcoinfees (third-party service)")))많은 Wallet 응용 프로그램은 요금 계산을 위해 타사 서비스를 사용합니다. 널리 사용되는 서비스 중 하나는 http://bitcoinfees.21.co/[_http://bitcoinfees.21.co_]이며 다른 우선 순위의 경우 satoshi / byte로 요금을 표시하는 시각적 차트와 API를 제공합니다.

[팁]
====
((("static fees")))((("fees", "static fees")))고정 비용은 비트 코인 네트워크에서 더 이상 유효하지 않습니다. 정적 수수료를 설정하는 지갑은 거래가 종종 멈추어 미확인 상태가되기 때문에 사용자 경험이 떨어집니다. Bitcoin 거래 및 수수료를 이해하지 못하는 사용자는 돈을 잃어 버렸다고 생각하여 '막힌'거래로 인해 당황 스럽습니다.
====

<< bitcoinfees21co >>의 차트는 각 범위에서 수수료가있는 트랜잭션의 예상 확인 시간 (분 및 블록 수)을 10 시간 단위로 늘린 실시간 평가를 보여줍니다. 각 요금 범위 (예 : 61 & # x2013; 70 satoshi / byte)에 대해 두 개의 가로 막대는 미확인 거래 수 (1405)와 지난 24 시간 (102,975)의 거래 총 수를 보여줍니다. 그래프에 따르면이 시점에서 권장되는 우선 순위 수수료는 80 satoshi / byte였으며 다음 번 블록 (0 블록 지연)에서 트랜잭션을 채굴 할 가능성이 높습니다. 관점에서 트랜잭션 크기의 중앙값은 226 바이트이므로 권장 트랜잭션 비용은 18,080 satoshis (0.00018080 BTC)입니다.

수수료 견적 데이터는 https://bitcoinfees.21.co/api/v1/fees/recommended[https://bitcoinfees.21.co/api/v1/fees/recommended에서 간단한 HTTP REST API를 통해 검색 할 수 있습니다. ]. 예를 들어, + curl + 명령을 사용하는 명령 행에서 다음을 수행하십시오.

. 요금 산정 API 사용
----
$ curl https://bitcoinfees.21.co/api/v1/fees/recommended

{"fastestFee":80,"halfHourFee":80,"hourFee":60}
----

API는 가장 빠른 확인 (+ fastestFee +), 바이트 당 satoshi의 세 블록 (+ halfHourFee +) 및 여섯 블록 (+ hourFee +) 내 확인을 위해 현재 요금 견적을 사용하여 JSON 객체를 반환합니다.

[[bitcoinfees21co]]
.Fee estimation service bitcoinfees.21.co
image::images/mbc2_0602.png[Fee Estimation Service bitcoinfees.21.co]

==== 거래 수수료 추가

거래의 데이터 구조에는 수수료 필드가 없습니다. 대신 수수료는 입력 합계와 출력 합계의 차이로 암시됩니다. 모든 산출물이 모든 투입물에서 공제 된 후에 남은 초과분은 광부가 수집 한 수수료입니다.

[[tx_fee_equation]]
. 거래 수수료는 입력 과잉이 산출물을 뺀 것이므로 암시된다.
----
수수료 = 합계 (입력) - 합계 (출력)
----

이것은 거래의 다소 혼란스러운 요소이며 이해해야 할 중요한 점입니다. 왜냐하면 자신의 거래를 구성하는 경우 입력을 줄임으로써 실수로 매우 많은 수수료를 포함시키지 않아야하기 때문입니다. 즉, 필요한 경우 변경 사항을 작성하여 모든 입력을 고려해야하며 그렇지 않으면 광부에게 매우 중요한 정보를 제공하게됩니다.

예를 들어, 20bitcoin UTXO를 사용하여 1 비트 동전 결제를하는 경우 19 비트 동전 변경 출력을 지갑에 다시 포함시켜야합니다. 그렇지 않으면 19 비트 코코아 잔액이 거래 수수료로 계산되며 거래를 광산에서 채광합니다. 당신이 우선 처리를하고 광부를 매우 행복하게 만들지 만, 이것은 아마도 당신이 의도 한 것이 아닙니다.

[경고]
====
((("warnings and cautions", "change outputs")))수동으로 생성 된 트랜잭션에 변경 출력을 추가하는 것을 잊어 버린 경우 변경을 트랜잭션 수수료로 지불하게됩니다. "잔돈!" 당신이 의도 한 바가 아닐 수도 있습니다.
====

((("use cases", "buying coffee")))앨리스의 커피 구입을 다시 살펴봄으로써 이것이 실제로 어떻게 작동하는지 봅시다. Alice는 커피를 지불하기 위해 0.015 bitcoin을 소비하려고합니다. 이 거래가 즉시 처리되도록하려면 거래 수수료 (예 : 0.001)를 포함하기를 원할 것입니다. 즉, 총 거래 비용은 0.016이됩니다. 따라서 그녀의 지갑은 0.016 비트 코 인 이상을 추가하는 UTXO 세트를 제공해야하며, 필요한 경우 변경을 작성해야합니다. 지갑에 0.2 비트 동전 UTXO가 있다고 가정 해 보겠습니다. 따라서이 UTXO를 소비하고, Bob 's Cafe에 0.015로 하나의 출력을 만들고, 0.184 비트 동전으로 자신의 지갑에 다시 출력하고, 0.001 비트 동전을 할당하지 않은 상태로 트랜잭션에 대한 암시 적 요금으로 생성해야합니다.

((("use cases", "charitable donations")))((("charitable donations")))이제 다른 시나리오를 살펴 보겠습니다. 필리핀의 자선 단체 인 Eugenia는 어린이를위한 교과서 구입을위한 모금 활동을 완료했습니다. 그녀는 50 명의 비트 코인 (bitcoin)을 합계하여 전 세계 사람들로부터 수천 건의 작은 기부금을 받았으며, 지갑에는 아주 작은 지불금 (UTXO)이 가득합니다. 이제 그녀는 현지 출판사로부터 수백 개의 교과서를 구입하여 비트 코로 지불하려고합니다.

Eugenia의 지갑 응용 프로그램은 하나의 큰 지불 트랜잭션을 생성하려고 시도하기 때문에 많은 작은 금액으로 구성된 사용 가능한 UTXO 집합을 소스로 사용해야합니다. 즉, 결과로 나오는 트랜잭션은 100 개의 작은 값의 UTXO를 입력으로 사용하고 하나의 출력만을 책 게시자에게 지불하게됩니다. 그 많은 입력을 가진 트랜잭션은 1 킬로바이트, 아마도 1 킬로바이트 또는 몇 킬로바이트보다 클 것입니다. 따라서 중간 규모 거래보다 훨씬 높은 수수료가 부과됩니다.

Eugenia의 지갑 응용 프로그램은 거래 규모를 측정하고이를 킬로바이트 당 수수료로 곱하여 적절한 수수료를 계산합니다. 많은 지갑은 거래가 신속하게 처리 될 수 있도록 더 큰 거래 비용을 초과 지불합니다. 더 높은 수수료는 Eugenia가 더 많은 돈을 지출하기 때문에 발생하는 것이 아니라 트랜잭션이 더 복잡하고 크기가 더 크기 때문에 - 거래 비용은 거래의 비트 동전 값과 별개입니다.((("", startref="Tout06")))

[[tx_script]]
[role="pagebreak-before less_space_h1"]
=== 트랜잭션 스크립트 및 스크립트 언어

((("transactions", "scripts and Script language", id="Tsript06")))((("scripting", "transactions and", id="Stransact06")))비트 스크립트 트랜잭션 스크립트 언어 인 _Script_ (_ ( "트랜잭션", "스크립트 및 스크립트 언어", id = "Tsript06")) 는 역방향 폴란드어 표기법 스택 기반 실행 언어와 같은 Forth입니다. 그 말이 횡설수설스러운 것처럼 들리면, 아마도 1960 년대의 프로그래밍 언어를 공부하지 않았을 것입니다.하지만 괜찮습니다.이 장에서 다룰 것입니다. UTXO에 배치 된 잠금 스크립트와 잠금 해제 스크립트는 모두이 스크립팅 언어로 작성됩니다. 트랜잭션의 유효성을 검사 할 때 각 입력의 잠금 해제 스크립트는 해당 잠금 스크립트와 함께 실행되어 지출 조건을 충족시키는 지 확인합니다.

스크립트는 범위가 제한되고 임베디드 장치처럼 단순한 하드웨어 범위에서 실행되도록 설계된 매우 단순한 언어입니다. 최소한의 처리 만 필요로하고 현대 프로그래밍 언어가 할 수있는 멋진 것들을 많이 할 수는 없습니다. 프로그래밍 가능한 자금의 유효성 확인에 사용하기 위해 이는 신중한 보안 기능입니다.

((("Pay-to-Public-Key-Hash (P2PKH)")))오늘날 비트 코인 네트워크를 통해 처리되는 대부분의 트랜잭션은 "Bob의 비트 코인 주소 지불"형식을 가지며 Pay-to -Public-Key-Hash 스크립트. 그러나 Bitcoin 트랜잭션은 "Bob의 Bitcoin 지불"스크립트로 제한되지 않습니다. 실제로 스크립트를 잠그면 다양한 복잡한 조건을 표현할 수 있습니다. 이러한 복잡한 스크립트를 이해하려면 먼저 트랜잭션 스크립트 및 스크립트 언어의 기본 사항을 이해해야합니다.

이 섹션에서는 비트 동전 트랜잭션 스크립팅 언어의 기본 구성 요소를 보여주고 단순한 지출 조건을 표현하는 데이 코드를 사용하여 스크립트를 잠금 해제하여 이러한 조건을 충족시키는 방법을 보여줍니다.

[TIP]
====
((("programmable money")))Bitcoin 트랜잭션 유효성 검사는 정적 패턴을 기반으로하지 않고 대신 스크립팅 언어의 실행을 통해 수행됩니다. 이 언어는 거의 무한한 다양한 조건을 표현할 수있게합니다. 이것이 비트 코인이 "프로그래밍 가능한 돈"의 힘을 얻는 방법입니다.
====


==== 불완전한 튜링

((("Turing incompleteness")))bitcoin 트랜잭션 스크립트 언어에는 많은 연산자가 포함되지만 의도적으로 한 가지 중요한 방법으로 제한됩니다. 조건부 흐름 제어 이외의 루프 또는 복잡한 흐름 제어 기능이 없습니다. 이렇게하면 언어가 _Turing Complete_가 아니므로 스크립트의 복잡성과 예측 가능한 실행 시간이 제한됩니다. 스크립트는 범용 언어가 아닙니다. (( "보안", "서비스 거부 공격") (( "서비스 거부 공격"))) ((( "서비스 거부 공격", " ))) 이러한 제한 사항은 비트 코인 네트워크에 대한 서비스 거부 공격을 유발하는 방식으로 트랜잭션에 포함될 수있는 무한 루프 또는 다른 형태의 "논리 폭탄"을 작성하는 데 언어를 사용할 수 없도록합니다. 모든 거래는 Bitcoin 네트워크의 모든 전체 노드에 의해 유효성이 확인됩니다. 제한된 언어는 트랜잭션 유효성 검증 메커니즘이 취약점으로 사용되는 것을 방지합니다.

==== Stateless Verification

((("stateless verification")))bitcoin 트랜잭션 스크립트 언어는 스크립트를 실행하기 전에 상태가 없거나 스크립트를 실행 한 후에 상태가 저장된다는 점에서 stateless입니다. 따라서 스크립트를 실행하는 데 필요한 모든 정보가 스크립트에 포함됩니다. 스크립트는 모든 시스템에서 예상대로 같은 방식으로 실행됩니다. 시스템이 스크립트를 검증하면 비트 코인 네트워크의 다른 모든 시스템도 스크립트를 검증하므로 유효한 트랜잭션이 모든 사람에게 유효하며 모든 사람이이를 알고 있음을 확인할 수 있습니다. 이 결과의 예측 가능성은 비트 코인 시스템의 필수 이점입니다.

[[tx_lock_unlock]]
==== 스크립트 구성 (잠금 + 잠금 해제)

Bitcoin의 트랜잭션 유효성 검사 엔진은 트랜잭션을 확인하는 두 가지 유형의 스크립트 인 잠금 스크립트와 잠금 해제 스크립트에 의존합니다.

((("locking scripts")))((("unlocking scripts")))((("scripting", "locking scripts")))잠금 스크립트는 출력에 대한 지출 조건으로 조건을 지정합니다 미래에 산출물을 소비하기 위해서는 반드시 충족되어야합니다. ((( "scriptPubKey"))) 역사적으로 잠금 스크립트는 _scriptPubKey_라고 불렀습니다. 대개 공개 키 또는 비트 코인 주소 (공개 키 해시)가 포함되어 있기 때문입니다. 이 책에서 우리는이 스크립팅 기술의 훨씬 더 광범위한 가능성을 인정하는 "잠금 스크립트"라고합니다. 대부분의 비트 코킹 어플리케이션에서, 우리가 로킹 스크립트라고 부르는 것은 소스 코드에 + scriptPubKey +로 나타날 것입니다. (( "(목격자)))) (("암호 퍼즐 "))) _ _ 증인 스크립트 _ (see << segwit >>) 또는 더 일반적으로 _cryptographic puzzle_으로 알려진 잠금 스크립트를 볼 수 있습니다. 이 용어들은 모두 서로 다른 추상화 수준에서 동일한 것을 의미합니다.

잠금 해제 스크립트는 잠금 스크립트에 의해 출력에 설정된 조건을 "해결하거나"만족시키는 스크립트로, 출력을 소비합니다. 잠금 해제 스크립트는 모든 트랜잭션 입력의 일부입니다. 대부분의 경우 사용자의 개인 키로부터 사용자의 지갑에서 생성 된 디지털 서명이 들어 있습니다. ((( "scriptSig"))) 역사적으로 잠금 해제 스크립트는 일반적으로 디지털 서명이 포함되어 있으므로 _scriptSig_라고 불렀습니다. 대부분의 비트 코킹 애플리케이션에서 소스 코드는 + scriptSig +와 같은 잠금 해제 스크립트를 참조합니다. 또한 _ _ 증인이라고하는 잠금 해제 스크립트가 표시됩니다 (<< segwit >> 참조). 이 책에서는 모든 잠금 해제 스크립트가 서명을 포함하지 않아야하므로 잠금 스크립트 요구 사항의 훨씬 더 넓은 범위를 인정하는 "잠금 해제 스크립트"라고합니다.

모든 비트 코인 유효성 검사 노드는 잠금 및 잠금 해제 스크립트를 함께 실행하여 트랜잭션의 유효성을 검사합니다. 각 입력에는 잠금 해제 스크립트가 포함되어 있으며 기존의 UTXO를 참조합니다. 유효성 검사 소프트웨어는 잠금 해제 스크립트를 복사하고 입력으로 참조되는 UTXO를 검색 한 다음 해당 UTXO에서 잠금 스크립트를 복사합니다. 잠금 해제 및 잠금 스크립트가 순서대로 실행됩니다. 잠금 해제 스크립트가 잠금 스크립트 조건을 만족하면 입력이 유효합니다 (<< script_exec >> 참조). 모든 입력은 트랜잭션의 전체 유효성 검사의 일부로 독립적으로 유효성이 검사됩니다.

UTXO는 블록 체인에 영구적으로 기록되므로 새로운 트랜잭션에서 참조로 사용하려는 시도가 실패해도 UTXO는 변경되지 않고 영향을받지 않습니다. 출력 조건을 정확하게 만족시키는 유효한 트랜잭션 만 출력이 "소비"된 것으로 간주되어 미사용 트랜잭션 출력 집합 (UTXO 집합)에서 제거됩니다.

<< scriptSig_and_scriptPubKey >>는 가장 일반적인 유형의 Bitcoin 트랜잭션 (공개 키 해시로의 지불)에 대한 잠금 해제 및 잠금 스크립트의 예이며 스크립트 유효성 검사에 앞서 잠금 해제 및 잠금 스크립트 연결의 결과로 결합 된 스크립트를 보여줍니다 .

[[scriptSig_and_scriptPubKey]]
.Combining scriptSig and scriptPubKey to evaluate a transaction script
image::images/mbc2_0603.png["scriptSig_and_scriptPubKey"]

===== 스크립트 실행 스택

Bitcoin의 스크립팅 언어는 _stack_이라는 데이터 구조를 사용하기 때문에 스택 기반 언어라고합니다. 스택은 카드 스택으로 시각화 할 수있는 매우 간단한 데이터 구조입니다. 스택은 push와 pop의 두 가지 조작을 허용합니다. 푸시는 스택 위에 항목을 추가합니다. Pop은 스택에서 최상위 항목을 제거합니다. 스택에 대한 작업은 스택에있는 최상위 항목에서만 작동 할 수 있습니다. 스택 데이터 구조는 Last-In-First-Out 또는 "LIFO"큐라고도합니다.

스크립팅 언어는 각 항목을 왼쪽에서 오른쪽으로 처리하여 스크립트를 실행합니다. 숫자 (데이터 상수)가 스택에 푸시됩니다. 연산자는 스택에서 하나 이상의 매개 변수를 푸시 또는 팝하고 스택에 작용하여 결과를 스택으로 푸시 할 수 있습니다. 예를 들어, + OP_ADD +는 스택의 두 항목을 팝업으로 추가하고 결과 합을 스택에 푸시합니다.

조건부 연산자는 조건을 평가하여 TRUE 또는 FALSE의 부울 결과를 생성합니다. 예를 들어, + OP_EQUAL +는 스택에서 두 항목을 팝하고 TRUE (TRUE는 숫자 1로 나타남)를 같거나 같지 않으면 FALSE (0으로 표시)를 푸시합니다. Bitcoin 트랜잭션 스크립트에는 대개 조건부 연산자가 포함되어 있으므로 유효한 트랜잭션을 나타내는 TRUE 결과를 생성 할 수 있습니다.

===== 간단한 스크립트

이제 스크립트와 스택에 대해 배운 내용을 간단한 예제에 적용 해 보겠습니다.

<< simplemath_script >>에서 스크립트 +2 3 OP_ADD 5 OP_EQUAL +는 산술 가산 연산자 + OP_ADD +를 보여주고, 두 개의 숫자를 더하고 그 결과를 스택에 넣은 다음 조건 연산자 + OP_EQUAL +을 사용하여 결과 합이 같은지 확인합니다 +5 +. 간략히하기 위해 + OP_ + 접두사는 단계별 예제에서 생략되었습니다. 사용 가능한 스크립트 연산자 및 함수에 대한 자세한 내용은 << tx_script_ops >>를 참조하십시오.

대부분의 잠금 스크립트는 공개 키 해시 (본질적으로 비트 코인 주소)를 참조하기 때문에 자금을 사용하기 위해 소유권을 증명해야하므로 스크립트가 복잡하지 않아도됩니다. TRUE 값을 갖는 잠금 및 잠금 해제 스크립트의 모든 조합이 유효합니다. 스크립팅 언어의 예로 사용 된 간단한 산술 연산은 트랜잭션 출력을 잠그는 데 사용할 수있는 유효한 잠금 스크립트이기도합니다.

산술 예제 스크립트의 일부를 잠금 스크립트로 사용하십시오.

----
3 OP_ADD 5 OP_EQUAL
----

잠금 해제 스크립트로 입력을 포함하는 트랜잭션이 만족할 수 있습니다.

----
2
----

유효성 검사 소프트웨어는 잠금 및 잠금 해제 스크립트를 결합하고 결과 스크립트는 다음과 같습니다.

----
2 3 OP_ADD 5 OP_EQUAL
----

<< simplemath_script >>의 단계별 예제에서 보았 듯이이 스크립트가 실행될 때 결과는 + OP_TRUE +가되어 트랜잭션이 유효하게됩니다. 이것은 유효한 트랜잭션 출력 잠금 스크립트 일뿐만 아니라 그 결과 UTXO는 숫자 2가 스크립트를 충족시키는지를 알기 위해 산술 스킬을 가진 사람이 소비 할 수 있습니다.

[팁]
====
스택의 최상위 결과가 + TRUE + (++ & # x7b; 0x01 & # x7d; ++로 표시), 다른 0이 아닌 값 또는 0보다 크거나 같으면 트랜잭션은 유효합니다 (( "트랜잭션", "유효 및 무효")) 또는 스크립트 실행 후 스택이 비어있는 경우. 스택의 최상위 값이 + FALSE + (++ & # x7b; & # x7d; ++로 표시된 길이가 0 인 빈 값)이거나 스크립트 실행이 + 연산자와 같은 연산자에 의해 명시 적으로 중단 된 경우 트랜잭션은 유효하지 않습니다. OP_VERIFY +, + OP_RETURN + 또는 + OP_ENDIF +와 같은 조건부 종료 자. 자세한 내용은 << tx_script_ops >>를 참조하십시오.
====

[[simplemath_script]]
.Bitcoin's script validation doing simple math
image::images/mbc2_0604.png["TxScriptSimpleMathExample"]

[role="pagebreak-before"]
다음은 ++ 2 + 7 - 3 + 1 ++를 계산하는 약간 더 복잡한 스크립트입니다. 스크립트가 여러 연산자를 연속적으로 포함하고있을 때 스택은 한 연산자의 결과가 다음 연산자에 의해 처리되도록합니다.

----
2 7 OP_ADD 3 OP_SUB 1 OP_ADD 7 OP_EQUAL
----

연필과 종이를 사용하여 직접 앞의 스크립트를 검증 해보십시오. 스크립트 실행이 끝나면 스택에 + TRUE + 값을 지정해야합니다.

[[script_exec]]
===== 잠금 해제 및 잠금 스크립트의 개별 실행

((("security", "locking and unlocking scripts")))원래 비트 빈 클라이언트에서는 잠금 해제 및 잠금 스크립트가 연결되어 순서대로 실행되었습니다. 보안상의 이유로 2010 년에 변경되었는데, 이는 잘못된 형식의 잠금 해제 스크립트가 데이터를 스택으로 밀어 넣고 잠금 스크립트를 손상시킬 수있는 취약점으로 인해 변경되었습니다. 현재 구현에서 스크립트는 다음 설명과 같이 두 실행 사이에 전송 된 스택과 별도로 실행됩니다.

먼저 스택 실행 엔진을 사용하여 잠금 해제 스크립트가 실행됩니다. 잠금 해제 스크립트가 오류없이 실행되면 (예 : "dangling"연산자가 남아 있지 않은 경우) 메인 스택 (대체 스택이 아님)이 복사되고 잠금 스크립트가 실행됩니다. 잠금 해제 스크립트에서 복사 된 스택 데이터로 잠금 스크립트를 실행 한 결과가 "TRUE"이면 잠금 해제 스크립트가 잠금 스크립트에 의해 부과 된 조건을 해결하는 데 성공 했으므로 입력이 UTXO를 사용할 수있는 유효한 권한입니다 . 결합 된 스크립트 실행 후 "TRUE"이외의 결과가 남아 있으면 UTXO에 대한 지출 조건을 충족시키지 못해 입력이 유효하지 않습니다.

[[p2pkh]]
==== Pay-to-Public-Key-Hash (P2PKH)

((("Pay-to-Public-Key-Hash (P2PKH)")))Bitcoin 네트워크에서 처리되는 트랜잭션의 대부분은 Pay-to-Public-Key-Hash 또는 "P2PKH"스크립트로 고정되어 있습니다. 이러한 출력에는 공개 키 해시 (일반적으로 비트 코인 주소라고 함)로 출력을 잠그는 잠금 스크립트가 포함되어 있습니다. P2PKH 스크립트에 의해 잠겨진 출력은 공개 키와 해당 개인 키 ( "digital_sigs"참조)에 의해 생성 된 디지털 서명을 제시함으로써 잠금 해제 (소비) 될 수 있습니다.

((("use cases", "buying coffee")))예를 들어 앨리스가 밥스 카페에 다시 지불하는 것을 살펴 보겠습니다. Alice는 카페 비트 코인 주소에 0.015 bitcoin을 지불했습니다. 해당 트랜잭션 출력에는 다음 형식의 잠금 스크립트가 있습니다.

----
OP_DUP OP_HASH160 <Cafe Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG
----

+ Cafe Public Key 해시 +는 Base58Check 인코딩이없는 카페의 비트 코인 주소와 동일합니다. 대부분의 응용 프로그램에서는 "1."로 시작하는 친숙한 비트 코인 주소 Base58Check 형식이 아닌 16 진수 인코딩으로 _public 키 hash_를 표시합니다.

이전 잠금 스크립트는 다음 형식의 잠금 해제 스크립트로 충족 될 수 있습니다.

----
<카페 서명> <카페 공개 키>
----

두 스크립트는 다음과 같이 결합 된 유효성 검사 스크립트를 형성합니다.

----
<카페 서명> <카페 공개 키> OP_DUP OP_HASH160
<카페 공개 키 해시> OP_EQUALVERIFY OP_CHECKSIG
----

실행될 때 잠금 해제 스크립트가 잠금 스크립트에 의해 설정된 조건과 일치하는 경우에만이 결합 된 스크립트는 TRUE로 평가됩니다. 즉, 잠금 해제 스크립트가 공개 키 해시에 상응하는 카페의 개인 키에서 유효한 서명을 가지면 TRUE가됩니다.

피규어가 전달됩니다 : [<a data-type="xref" href="#P2PubKHash1" data-xrefstyle="select: labelnumber"> # P2PubKHash1 </a>] 및 전달 : [<a a data-type = "xref"href = "# P2PubKHash2"data-xrefstyle = "select : labelnumber"> # P2PubKHash2 </a>]는 결합 된 스크립트의 단계별 실행을 보여 주며 이는 유효한 트랜잭션임을 증명합니다. (( "" ", startref ="Stransact06 "))) ((" ", startref ="Tsript06 "

[[P2PubKHash1]]
.Evaluating a script for a P2PKH transaction (part 1 of 2)
image::images/mbc2_0605.png["Tx_Script_P2PubKeyHash_1"]

[[P2PubKHash2]]
.Evaluating a script for a P2PKH transaction (part 2 of 2)
image::images/mbc2_0606.png["Tx_Script_P2PubKeyHash_2"]

[[digital_sigs]]
=== 디지털 서명 (ECDSA)

((("transactions", "digital signatures and", id="Tdigsig06")))지금까지 우리는 "디지털 서명"에 대해 자세히 설명하지 않았습니다. 이 섹션에서는 디지털 서명이 작동하는 방식과 개인 키를 공개하지 않고 개인 키의 소유권 증명을 제시 할 수있는 방법을 살펴 봅니다.

((("digital signatures", "algorithm used")))((("Elliptic Curve Digital Signature Algorithm (ECDSA)")))비트 코인에 사용되는 전자 서명 알고리즘은 _Elliptic Curve Digital Signature Algorithm _ _ 또는 _ECDSA_이다. ECDSA는 << elliptic_curve >>에서 설명한대로 타원 곡선 개인 / 공개 키 쌍을 기반으로하는 디지털 서명에 사용되는 알고리즘입니다. ECDSA는 스크립트 함수 + OP_CHECKSIG +, + OP_CHECKSIGVERIFY +, + OP_CHECKMULTISIG + 및 + OP_CHECKMULTISIGVERIFY +에 사용됩니다. 잠금 스크립트에서 해당 내용을 볼 때마다 잠금 해제 스크립트에 ECDSA 서명이 있어야합니다.

((("digital signatures", "purposes of")))디지털 서명은 비트 코인의 세 가지 용도로 사용됩니다 (다음 세로 막대 참조). 첫째, 서명은 함축적으로 기금 소유자 인 개인 키 소유자가 해당 기금의 사용을 허가했음을 증명합니다. 둘째, 허가의 증거가 _ 가능합니다 (부인 방지). 셋째, 서명은 거래 (또는 거래의 특정 부분)가 서명되지 않은 사람이면 누구도 수정할 수 없으며 변경할 수 없음을 증명합니다.

각 거래 입력은 독립적으로 서명됩니다. 이는 서명이나 입력이 모두 동일한 "소유주"에 속하거나 적용되어야하므로 중요합니다. 실제로 "CoinJoin"이라는 특정 거래 체계는이 사실을 사용하여 개인 정보 보호를위한 다자간 거래를 생성합니다.

[노트]
====
각 거래 입력 및 그것이 포함 할 수있는 모든 서명은 _ 완전하게 다른 입력 또는 서명과 독립적입니다. 여러 당사자가 협업하여 트랜잭션을 구성하고 각각 하나의 입력에만 서명 할 수 있습니다.
====

[[digital_signature_definition]]
.Wikipedia's Definition of a "Digital Signature"
****
((("digital signatures", "defined")))디지털 서명은 디지털 메시지 또는 문서의 진위성을 입증하는 수학적 체계입니다. 유효한 디지털 서명은 메시지가 알려진 발신자 (인증)에 의해 생성되었고, 발신자가 메시지를 보냈음을 부인할 수없고 (부인 방지) 메시지가 전송 중에 변경되지 않았다고 (믿을만한 이유를 제공합니다.

_ 출처: https://en.wikipedia.org/wiki/Digital_signature_
****

==== 디지털 서명 작동 방식

((("digital signatures", "how they work")))디지털 서명은 두 부분으로 구성된 _ 수학적 체계입니다. 첫 번째 부분은 메시지 (트랜잭션)에서 개인 키 (서명 키)를 사용하여 서명을 만드는 알고리즘입니다. 두 번째 부분은 누구나 서명과 메시지 및 공개 키를 확인할 수있는 알고리즘입니다.

===== 디지털 서명 만들기

Bitcoin의 ECDSA 알고리즘 구현에서 서명되는 "메시지"는 트랜잭션이거나 트랜잭션의 특정 데이터 하위 집합에 대한 해시입니다 (<< sighash_types >> 참조). 서명 키는 사용자의 개인 키입니다. 결과는 다음과 같습니다.

latexmath:[\(Sig = F_{sig}(F_{hash}(m), dA)\)]

* _dA_는 서명 개인 키입니다.
* _m_은 거래 (또는 그 일부)입니다.
* _F_ ~ _hash_ ~는 해시 함수입니다.
* _F_ ~ _sig_ ~는 서명 알고리즘입니다.
* _Sig_는 결과 서명입니다.

ECDSA의 수학에 대한 자세한 내용은 << ecdsa_math >>에서 찾을 수 있습니다.

함수 _F_ ~ _sig_ ~는 일반적으로 + R +와 + S +라고하는 두 개의 값으로 구성된 시그니처 + Sig +를 생성합니다.

----
Sig = (R, S)
----

((("Distinguished Encoding Rules (DER)")))+ R +와 + S +의 두 값이 계산되었으므로 _Distinguished Encoding Rules_ 또는 _DER_라는 국제 표준 인코딩 체계를 사용하여 바이트 스트림으로 직렬화됩니다.

[[seralization_of_signatures_der]]
===== 서명 직렬화 (DER)

Alice (( "유스 케이스", "커피 구매", id = "alicesixtwo")) 트랜잭션을 살펴 보겠습니다. 트랜잭션 입력에는 Alice의 지갑에서 DER로 인코딩 된 다음 시그니처가 포함 된 잠금 해제 스크립트가 있습니다.

----
3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301
----



이 서명은 Alice의 지갑에서 생성 된 + R + 및 + S + 값의 직렬화 된 바이트 스트림으로, 해당 출력을 보낼 권한이있는 개인 키를 소유하고 있음을 증명합니다. 직렬화 형식은 다음과 같은 9 개의 요소로 구성됩니다.

DER 시퀀스의 시작을 나타내는 * + 0x30 + & # x14;
* + 0x45 + & # x2014; 시퀀스의 길이 (69 바이트)
  * + 0x02 + & # x20; 정수 값 뒤에옵니다.
  * + 0x21 + & # x2014; 정수의 길이 (33 바이트)
  * + R + & ++ 00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb ++
  * + 0x02 + & # x2014; 다른 정수가 뒤에옵니다.
  * + 0x20 + & # x2014; 정수의 길이 (32 바이트)
  * + S + & # x2014; ++ 4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813 ++
* 사용 된 해시 유형을 나타내는 접미사 (+ 0x01 +) (+ SIGHASH_ALL +)

이 목록을 사용하여 앨리스의 직렬화 된 (DER로 인코딩 된) 서명을 디코딩 할 수 있는지 확인하십시오. 중요한 숫자는 + R +와 + S +입니다. 나머지 데이터는 DER 코드화 체계의 일부입니다.

==== 서명 확인하기

서명을 확인하려면 서명 (+ R + 및 + S +), 일련 화 된 트랜잭션 및 공개 키 (생성하는 데 사용 된 개인 키에 해당)가 있어야합니다. (( "디지털 서명", "확인")) 서명). 본질적으로 서명 확인은 "이 공개 키를 생성 한 개인 키의 소유자 만이이 트랜잭션에서이 서명을 생성 할 수 있습니다."라는 의미입니다.

서명 확인 알고리즘은 메시지 (트랜잭션의 해시 또는 그 일부), 서명자의 공개 키 및 서명 (+ R + 및 + S + 값)을 가져 와서 서명이이 메시지 및 공개 키에 유효하면 TRUE를 반환합니다.

[[sighash_types]]
==== Signature Hash Types (SIGHASH)

((("digital signatures", "signature hash types")))((("commitment")))디지털 서명은 비트 동전의 경우 트랜잭션 자체 인 메시지에 적용됩니다. 서명은 특정 트랜잭션 데이터에 대한 서명자의 _commitment_를 의미합니다. 가장 간단한 형태로, 서명은 전체 트랜잭션에 적용되어 모든 입력, 출력 및 기타 트랜잭션 필드를 커밋합니다. 그러나 서명은 트랜잭션에서 데이터의 하위 집합에만 커밋 할 수 있습니다. 이는이 섹션에서 볼 수있는 여러 시나리오에 유용합니다.

((("SIGHASH flags")))Bitcoin 서명은 트랜잭션 데이터의 어느 부분이 + SIGHASH + 플래그를 사용하여 개인 키로 서명 된 해시에 포함되는지 나타내는 방법을 가지고 있습니다. + SIGHASH + 플래그는 서명에 추가되는 단일 바이트입니다. 모든 서명에는 + SIGHASH + 플래그가 있으며 플래그는 입력과는 다를 수 있습니다. 3 개의 서명 된 입력을 가진 트랜잭션은 + SIGHASH + 플래그가 서로 다른 세 개의 서명을 가질 수 있으며 각 서명은 트랜잭션의 다른 부분에 서명 (커밋)합니다.

각 입력에는 잠금 해제 스크립트에 서명이 포함될 수 있습니다. 결과적으로, 여러 입력을 포함하는 트랜잭션은 각 입력에서 트랜잭션의 다른 부분을 커밋하는 + SIGHASH + 플래그가 다른 시그니처를 가질 수 있습니다. 비트 코인 트랜잭션에는 부분적으로 생성 된 (그리고 유효하지 않은) 트랜잭션에서 하나의 입력 만 서명하고 다른 트랜잭션과 협력하여 유효한 트랜잭션을 만들기 위해 필요한 모든 서명을 수집하는 다른 "소유자"의 입력이 포함될 수 있습니다. + SIGHASH + 플래그 유형의 대부분은 비트 코인 네트워크 외부에서 여러 참가자가 협력하고 부분 서명 된 트랜잭션을 업데이트한다고 생각하는 경우에만 의미가 있습니다.

[role="pagebreak-before"]
<< sighash_types_and_their >>에 표시된 것처럼 + ALL +, + NONE + 및 + SINGLE + 세 개의 + SIGHASH + 플래그가 있습니다.

[[sighash_types_and_their]]
.SIGHASH 유형과 그 의미
[options="header"]
| ===================================================
| + SIGHASH + 국기 | 가치 | 기술
| + ALL + | 0x01 | 서명은 모든 입력 및 출력에 적용됩니다.
| + NONE + | 0x02 | 서명은 모든 입력에 적용되며 출력은 없음
| + SINGLE + | 0x03 | 서명은 모든 입력에 적용되지만 서명 된 입력과 동일한 색인 번호를 갖는 하나의 출력에만 적용됩니다
| ===================================================

또한 수정 기호 플래그 + SIGHASH_ANYONECANPAY +가 있으며 앞의 각 플래그와 결합 될 수 있습니다. + ANYONECANPAY +가 설정되면 하나의 입력 만 서명되고, 나머지는 수정을 위해 열어 둔 채로 남겨 둡니다. + ANYONECANPAY +의 값은 + 0x80 +이며 비트 OR로 적용되므로 << sighash_types_with_modifiers >>와 같이 결합 된 플래그가됩니다.

[[sighash_types_with_modifiers]]
.수식어와 그 의미를 포함한 .SIGHASH 형
[options = "header"]
| ===================================================
| 시애틀 국기 | 가치 | 기술
| ALL \ | ANYONECANPAY | 0x81 | 서명은 하나의 입력 및 모든 출력에 적용됩니다.
| NONE \ | ANYONECANPAY | 0x82 | 서명은 하나의 입력에 적용되며 출력은 없음
| 싱글 \ | ANYONECANPAY | 0x83 | 하나의 입력에 서명이 적용되고 동일한 색인 번호를 갖는 출력
| ===================================================

서명 및 검증 중에 + SIGHASH + 플래그가 적용되는 방식은 트랜잭션 사본이 작성되고 내부의 특정 필드는 잘 렸습니다 (길이가 0으로 설정되고 비어 있음). 결과 트랜잭션이 직렬화됩니다. 직렬화 된 트랜잭션의 끝에 + SIGHASH + 플래그가 추가되고 결과가 해시됩니다. 해시 자체는 서명 된 "메시지"입니다. 어떤 + SIGHASH + 플래그가 사용되는지에 따라 트랜잭션의 다른 부분이 잘립니다. 결과 해시는 트랜잭션의 데이터 하위 집합에 따라 달라집니다. 해싱 전 + SIGHASH +를 마지막 단계로 포함하면 서명이 + SIGHASH + 유형을 커밋하므로 변경할 수 없습니다 (예 : 광부가).

[노트]
====
모든 + SIGHASH + 유형은 트랜잭션 + nLocktime + 필드에 서명합니다 (<< transaction_locktime_nlocktime >> 참조). 또한 + SIGHASH + 유형 자체는 서명되기 전에 트랜잭션에 추가되므로 서명 한 후에는 수정할 수 없습니다.
====

Alice의 트랜잭션 예제 (<< seralization_of_signatures_der >>의 목록 참조)에서 DER로 인코딩 된 서명의 마지막 부분은 +01+이며 + SIGHASH_ALL + 플래그임을 확인했습니다. 이렇게하면 트랜잭션 데이터가 잠기므로 Alice의 서명이 모든 입력과 출력의 상태를 확약합니다. 가장 일반적인 서명 양식입니다.

다른 + SIGHASH + 유형을 실제로 사용하는 방법을 살펴 보겠습니다.

+ ALL | ANYONECANPAY + :: ((( "자선 기부금"))) (( "유스 케이스", "자선 기부금")))이 건설은 "크라우드 펀딩 (crowdfunding)"스타일의 거래를하는 데 사용될 수 있습니다. 자금을 모으는 것은 하나의 산출물로 거래를 성사시킬 수있다. 단일 산출물은 모금액에 "목표액"을 지불한다. 그러한 거래는 분명히 유효하지 않다. 입력이 없으므로 분명히 유효하지만 다른 사람들은 입력 + ALL | ANYONECANPAY +를 사용하여 자신의 의견을 서명합니다. 출력 값에 도달하기위한 충분한 입력이 수집되지 않으면 거래가 유효하지 않습니다. 각 기부는 "기부"이며 전체 목표 금액이 올 때까지 모금 행사.

+ NONE + ::이 구조는 특정 금액의 "무기명 수표"또는 "수표"를 만드는 데 사용할 수 있습니다. 입력에 커밋하지만 출력 잠금 스크립트는 변경할 수 있습니다. 누구나 자신의 비트 코인 주소를 출력 잠금 스크립트에 기록하고 트랜잭션을 사용할 수 있습니다. 그러나 출력 값 자체는 서명에 의해 잠겨 있습니다.

+ NONE | ANYONECANPAY + : :이 구조는 "집진 장치"를 만드는 데 사용될 수 있습니다. 지갑에 작은 UTXO를 가지고있는 사용자는 먼지 값을 초과하는 비용을 지불하지 않고도이를 쓸 수 없습니다. 이러한 유형의 서명을 통해 먼지 UTXO는 원하는 사람이 언제든지 집계하고 지출 할 수 있도록 기부 할 수 있습니다.

((("Bitmask Sighash Modes")))+ SIGHASH + 시스템을 수정하거나 확장하기위한 몇 가지 제안이 있습니다. 이러한 제안 중 하나는 Blockstream의 Glenn Willen에 의한 _Bitmask Sighash Modes _이며, 이는 Elements 프로젝트의 일부입니다. 이것은 "분산 된 자산 교환의 변화와 함께 서명 된 오퍼와 같이 더 복잡한 계약상의 사전 약속 계획"을 표현할 수있는 "입출력의 임의의 마이너 재기록 가능한 비트 마스크"를 허용하는 + SIGHASH + 유형에 대한 유연한 대체를 만드는 것을 목표로합니다.

[노트]
====
사용자의 지갑 응용 프로그램에서 + SIGHASH + 플래그가 옵션으로 표시되지 않습니다. 예외는 거의 없지만 지갑은 P2PKH 스크립트를 작성하고 + SIGHASH_ALL + 플래그로 서명합니다. 다른 + SIGHASH + 플래그를 사용하려면 트랜잭션을 작성하고 서명하는 소프트웨어를 작성해야합니다. 더 중요한 것은 + SIGHASH + 플래그는 새로운 용도로 사용할 수있는 특수 용도의 비트 코인 응용 프로그램에서 사용할 수 있습니다.
====

[[ecdsa_math]]
==== ECDSA 수학

((("Elliptic Curve Digital Signature Algorithm (ECDSA)")))앞에서 언급했듯이, 서명은 두 개의 값 _R_과 _S_으로 구성된 서명을 생성하는 수학 함수 _F_ ~ _sig_ ~에 의해 생성됩니다. 이 절에서는 _F_ ~ _sig_ ~ 함수를 좀 더 자세히 살펴 보겠습니다.

((("public and private keys", "key pairs", "ephemeral")))서명 알고리즘은 먼저 _ephemeral_ (임시) 개인 공개 키 쌍을 생성합니다. 이 임시 키 쌍은 서명 개인 키와 트랜잭션 해시를 포함하는 변환 후 _R_ 및 _S_ 값을 계산하는 데 사용됩니다.

임시 키 쌍은 임시 개인 키로 사용되는 난수 _k_를 기반으로합니다. _k_에서 우리는 상응하는 임시 공개 키 _P_ (비트 동전 공개 키가 파생 된 것과 동일한 방식으로 _P = k * G_로 계산 됨, << pubkey >> 참조)를 생성합니다. 디지털 서명의 _R_ 값은 일시적인 공개 키 _P_의 x 좌표입니다.

거기에서 알고리즘은 다음과 같이 서명의 _S_ 값을 계산합니다.

_S_ = __k __ ^ - 1 ^ (__Hash __ (__ m__) + __dA__ * __R__) _mod p_

어디에:

* _k_는 임시 개인 키입니다.
* _R_는 임시 공개 키의 x 좌표입니다.
* _dA_는 서명 개인 키입니다.
* _m_는 거래 데이터입니다.
* _p_는 타원 곡선의 소수이다.

검증은 _R_, _S_ 값 및 공개 키를 사용하여 타원 곡선상의 점인 _P_ (서명 생성에 사용 된 임시 공개 키)를 계산하는 서명 생성 함수의 역입니다.

_P_ = __S __ ^ - 1 ^ * __Hash __ (__ m__) * _G_ + __S __ ^ - 1 ^ * _R_ * _Qa_

어디에:

* _R_ 및 _S_는 서명 값입니다.
* _Qa_는 Alice의 공개 키입니다.
* _m_은 서명 된 트랜잭션 데이터입니다.
* _G_는 타원 곡선 생성기 점입니다.

계산 된 포인트 _P_의 x 좌표가 _R_와 같으면 검증자는 서명이 유효하다고 결론을 내릴 수 있습니다.

서명을 검증 할 때 개인 키는 알려지지도 공개되지도 않습니다.

[팁]
====
ECDSA의 수학은 복잡하고 이해하기 어렵습니다. 도움이 될 수있는 온라인상의 훌륭한 가이드가 많이 있습니다. "ECDSA 설명"을 검색하거나 다음을 시도하십시오 : http://bit.ly/2r0HhGB [].
====

==== 서명의 임의성의 중요성

((("digital signatures", "randomness in")))<< ecdsa_math >>에서 보았 듯이, 서명 생성 알고리즘은 일시적인 개인 / 공개 키 쌍의 기초로 무작위 키 _k_를 사용합니다. _k_의 값은 중요하지 않으므로 _만큼 오래 _합니다. 서로 다른 메시지 (트랜잭션)에서 두 개의 서명을 생성하는 데 동일한 값 _k_가 사용되면 서명 _ 개인 키는 누구든지 계산할 수 있습니다. 서명 알고리즘에서 _k_와 동일한 값을 재사용하면 개인 키가 노출됩니다!

[주의]
====
((("warnings and cautions", "digital signatures")))두 개의 다른 트랜잭션에서 서명 알고리즘에 동일한 값 _k_이 사용되면 개인 키가 계산되어 전세계에 노출 될 수 있습니다!
====

이것은 이론적 인 가능성 만은 아닙니다. 우리는이 문제가 비트 코인 (bitcoin)의 트랜잭션 서명 알고리즘의 몇 가지 다른 구현에서 개인 키 노출에 이르는 것을 보았습니다. 실수로 _k_ 값을 재사용했기 때문에 사람들이 도난당했습니다. _k_ 값을 재사용하는 가장 일반적인 이유는 부적절하게 초기화 된 난수 생성기입니다.

((("random numbers", "random number generation")))((("entropy", "random number generation")))((("deterministic initialization")))이 취약점을 피하기 위해 업계 최고의 사례 엔트로피를 뿌린 난수 생성기로 _k_를 생성하지 않고 대신 트랜잭션 데이터 자체가 포함 된 결정 론적 랜덤 프로세스를 사용하는 것입니다. 이렇게하면 각 트랜잭션이 서로 다른 _k_을 생성합니다. _k_의 결정 론적 초기화를위한 산업 표준 알고리즘은 Internet Engineering Task Force에서 발행 한 https://tools.ietf.org/html/rfc6979[RFC 6979]에 정의되어 있습니다.

Bitcoin에서 트랜잭션을 서명하는 알고리즘을 구현하는 경우 RFC 6979 또는 유사 결정 론적 알고리즘을 사용하여 각 트랜잭션에 대해 서로 다른 _k_을 생성해야합니다. (( "" ", startref ="Tdigsig06 ")))

=== Bitcoin 주소, 균형 및 기타 추상화

((("transactions", "higher-level abstractions", id="Thigher06")))거래는 지갑, 블록 체인 탐험가, 및 기타 사용자 대면 응용 프로그램을 지원합니다. 비트 코인 주소 및 잔액과 같은 이전 장의 단순하고 친숙한 개념 중 많은 부분이 트랜잭션 구조에서 빠져있는 것처럼 보입니다. 우리는 거래가 비트 코인 주소를 포함하고 있지는 않지만 대신 비트 코 인의 개별 값을 잠 그거나 잠금 해제하는 스크립트를 통해 작업한다는 것을 알았습니다. 이 시스템의 어디에도 잔액이 없지만 모든 지갑 응용 프로그램은 사용자의 지갑 잔액을 눈에 잘 띄게 표시합니다.

이제 비트 코인 트랜잭션에 실제로 포함 된 것을 탐구 했으므로 트랜잭션의 겉으로 보이는 원시 구성 요소에서 더 높은 수준의 추상화가 어떻게 유도되는지 검토 할 수 있습니다.

Alice의 트랜잭션이 인기있는 블록 탐색기 (<< alice_transaction_to_bobs_cafe >>)에서 어떻게 표시되는지 다시 살펴 보겠습니다.

[[alice_transaction_to_bobs_cafe]]
.Alice's transaction to Bob's Cafe
image::images/mbc2_0208.png["Alice Coffee Transaction"]

트랜잭션의 왼쪽에서 블록 체인 탐색기는 앨리스의 비트 코인 주소를 "보낸 사람"으로 표시합니다. 사실,이 정보는 트랜잭션 자체에 없습니다. 블록 체인 탐색기가 트랜잭션을 검색하면 입력에서 참조 된 이전 트랜잭션을 검색하고 이전 트랜잭션의 첫 번째 출력을 추출합니다. 이 출력에는 UTXO를 Alice의 공개 키 해시 (P2PKH 스크립트)에 잠그는 잠금 스크립트가 있습니다. 블록 체인 탐색기는 공개 키 해시를 추출하여 Base58Check 인코딩을 사용하여 인코딩하여 공개 키를 나타내는 비트 코인 주소를 생성하고 표시합니다.

마찬가지로, 오른쪽에서 블록 체인 탐색기는 두 개의 출력을 보여줍니다. 첫 번째는 Bob의 비트 코인 주소이고 두 번째는 앨리스의 비트 코인 주소 (변경 사항)입니다. 이 비트 코인 주소를 생성하기 위해 블록 체인 탐색기는 각 출력에서 ​​잠금 스크립트를 추출하고이를 P2PKH 스크립트로 인식하고 내부에서 공개 키 해시를 추출했습니다. 마지막으로 블록 체인 탐색기는 Base58Check를 사용하여 공개 키 해시를 다시 인코딩하여 비트 코인 주소를 생성하고 표시합니다.

Bob의 비트 코인 주소를 클릭하면 블록 체인 탐색기가 << the_balance_of_bobs_bitcoin_address >>의보기를 표시합니다.

[[the_balance_of_bobs_bitcoin_address]]
.Bob의 비트 코인 주소의 잔액
image::images/mbc2_0608.png["The balance of Bob's bitcoin address"]

블록 체인 탐색기는 Bob의 비트 코인 주소의 균형을 표시합니다. 그러나 비트 코인 시스템 어디에도 "균형"이라는 개념이 있습니다. 오히려 여기에 표시된 값은 블록 체인 탐색기에 의해 다음과 같이 구성됩니다.

"Total Received"금액을 구성하기 위해 Blockchain 탐색기는 먼저 Bitcoin 주소의 Base58Check 인코딩을 디코딩하여 주소 내에 인코딩 된 Bob의 공개 키의 160 비트 해시를 검색합니다. 그런 다음 블록 체인 탐색기는 트랜잭션 데이터베이스를 검색하여 Bob의 공개 키 해시가 포함 된 P2PKH 잠금 스크립트로 출력을 찾습니다. 블록 체인 탐색기는 모든 출력의 값을 합하여 총 값을 산출 할 수 있습니다.

현재 잔액 ( "최종 잔액"으로 표시)을 구성하려면 약간 더 많은 작업이 필요합니다. 블럭 체인 탐색기는 현재 사용되지 않은 출력 인 UTXO의 별도 데이터베이스를 유지합니다. 이 데이터베이스를 유지하려면 블록 체인 탐색기가 비트 코인 네트워크를 모니터링하고 새로 생성 된 UTXO를 추가하며 사용되지 않은 트랜잭션에 나타나는대로 사용 된 UTXO를 실시간으로 제거해야합니다. 이는 트랜잭션이 전파 될 때 트랜잭션을 추적하는 것과 비트 코인 네트워크에 대한 합의를 유지하여 올바른 체인이 준수되는지 확인하는 복잡한 프로세스입니다. 때로는 블록 체인 탐색기가 동기화되지 않고 UTXO 세트에 대한 관점이 불완전하거나 부정확합니다.

블록 체인 탐색기는 UTXO 세트에서 Bob의 공개 키 해시를 참조하는 모든 미사용 출력의 값을 합산하고 사용자에게 표시된 "최종 잔액"번호를 생성합니다.

이 두 가지 "잔액"을 사용하여이 이미지 하나를 생성하려면 블록 체인 탐색기가 수십, 수백 또는 수십만 건의 트랜잭션을 인덱싱하고 검색해야합니다.

요약하면, Wallet 응용 프로그램, 블록 체인 탐색기 및 기타 Bitcoin 사용자 인터페이스를 통해 사용자에게 제공되는 정보는 여러 트랜잭션을 검색하고 해당 내용을 검사하며 그 안에 포함 된 데이터를 조작하여 파생 된 상위 수준 추상화로 구성되는 경우가 많습니다. 한 번의 발신자에서 한 명의 수령자에게 은행 수표와 유사한 비트 동전 거래에 대한이 단순한 관점을 제시함으로써 이러한 애플리케이션은 많은 기본 세부 사항을 추상화해야합니다. 주로 거래 유형에 초점을 맞 춥니 다. 모든 입력에 SIGHASH_ALL 서명이있는 P2PKH입니다. 따라서 비트 코인 애플리케이션은 모든 트랜잭션의 80 % 이상을 읽기 쉬운 방식으로 제공 할 수 있지만 표준에서 벗어나는 트랜잭션으로 인해 때로는 어려움을 겪을 수 있습니다. 보다 복잡한 잠금 스크립트 또는 다른 SIGHASH 플래그 또는 많은 입출력을 포함하는 트랜잭션은 이러한 추상화의 단순성과 약점을 보여줍니다.

매일 P2PKH 출력을 포함하지 않는 수백 건의 트랜잭션이 블록 체인에서 확인됩니다. 블록 체인 탐색기는 종종 주소를 디코딩 할 수 없다는 빨간색 경고 메시지를 표시합니다. 다음 링크는 완전히 디코딩되지 않은 가장 최근의 "이상한 거래"를 포함합니다 : https://blockchain.info/strange-transactions [].

다음 장에서 보게 되겠지만, 이것들은 반드시 이상한 거래는 아닙니다. 그들은 일반적인 P2PKH보다 복잡한 잠금 스크립트를 포함하는 트랜잭션입니다. 더 복잡한 스크립트와 그 스크립트가 지원하는 응용 프로그램을 디코딩하고 이해하는 방법을 배웁니다. ((("", startref="Thigher06")))((("", startref="alicesixtwo")))
