[[ch04_keys_addresses]]
== 열쇠, 주소

((("cryptography", "defined")))((("cryptography", see="also keys and addresses")))비트 암호화는 광범위하게 사용되는 수학의 한 부분 인 _cryptography_를 기반으로한다는 말을 들었을 것입니다. 컴퓨터 보안. 암호 법은 그리스어로 "비밀 작문"을 의미하지만, 암호학은 과학이라고하는 단순한 비밀 작문 이상을 포괄합니다. 또한 암호는 비밀 (디지털 서명)을 밝히지 않고도 비밀에 대한 지식을 증명하거나 데이터의 진위성 (디지털 지문)을 증명하는 데 사용할 수 있습니다. 이러한 유형의 암호화 증명은 비트 코인에 중요한 수학 도구이며 비트 코인 응용 프로그램에서 광범위하게 사용됩니다. (역으로 "("암호화 ")))) (("암호화 ","키와 주소 "참조)) 역설적이게도 암호화와 통신 데이터는 암호화되어 있지 않으므로 암호화는 비트 동전의 중요한 부분이 아닙니다. 자금을 보호하기 위해 암호화해야합니다. 이 장에서는 키 코드, 주소 및 지갑의 형태로 자금 소유권을 제어하기 위해 비트 코인에 사용되는 일부 암호화를 소개합니다.

=== 소개

((("digital keys", see="keys and addresses")))((("keys and addresses", "overview of", id="KAover04")))((("digital signatures", "purpose of")))bitcoin의 소유권은 _digital keys_, _bitcoin addresses_ 및 _digital signatures_를 통해 설정됩니다. 디지털 키는 실제로 네트워크에 저장되지 않지만 대신 사용자가 파일이나 _wallet_이라는 간단한 데이터베이스에 만들어 저장합니다. 사용자의 지갑에있는 디지털 키는 비트 동전 프로토콜과 완전히 독립적이며 블록 체인이나 인터넷 액세스를 언급하지 않고 사용자의 지갑 소프트웨어에서 생성 및 관리 할 수 ​​있습니다. 키를 사용하면 분산 된 트러스트 및 제어, 소유권 증명 및 암호화 방지 보안 모델을 비롯하여 비트 코인의 흥미로운 많은 속성을 사용할 수 있습니다.

대부분의 비트 동전 거래에는 블록 키에 유효한 디지털 서명이 포함되어야합니다.이 서명은 비밀 키로 만 생성 할 수 있습니다. 따라서 해당 키의 사본을 가진 사람은 누구나 비트 코인을 제어 할 수 있습니다. (( "증인"))) 자금 사용에 사용되는 디지털 서명은 암호문에 사용되는 용어 인 _ 증인이라고도합니다. 비트 동전 거래의 증인 데이터는 지출 된 자금의 실제 소유권을 증명합니다.

((("public and private keys", "key pairs")))((("public and private keys", see="also keys and addresses")))참조)) 키는 개인 키 (비밀 키)로 구성된 쌍으로 구성됩니다 (("( "공개 키 및 개인 키", "키 쌍")))) 및 공개 키를 포함한다. 공개 키는 은행 계좌 번호와 같고 비공개 키는 비공개 PIN 또는 수표의 서명과 유사하게 계정을 제어합니다. 이러한 디지털 키는 비트 동전 사용자에게는 거의 볼 수 없습니다. 대부분의 경우 지갑 파일 내부에 저장되고 Bitcoin Wallet 소프트웨어로 관리됩니다.

Bitcoin 트랜잭션의 지불 부분에서 수취인의 공개 키는 수취인 이름과 동일한 방식으로 사용되는 _bitcoin address_라는 디지털 지문으로 표현됩니다 (즉, "주문 대금 지불"). . 대부분의 경우 비트 코인 주소는 공개 키에서 생성되고 공개 키에 해당합니다. 그러나 모든 비트 코인 주소가 공개 키를 나타내는 것은 아닙니다. 이 장의 뒷부분에서 볼 수 있듯이 스크립트와 같은 다른 수혜자를 나타낼 수도 있습니다. 이렇게하면, 비트 코인은 사람들의 계좌로 지불하거나, 회사 계좌로 지불하거나, 청구서를 지불하거나, 현금으로 지불하는 데 사용할 수있는 단일 지불 수단 인 종이 수표와 비슷한 거래 대상을 융통성있게 만드는 자금 수취인을 추상화합니다. 비트 코인 주소는 사용자가 일상적으로 보게 될 키의 유일한 표현입니다. 왜냐하면 이것이 세계와 공유해야하는 부분이기 때문입니다.

먼저, 암호 기술을 소개하고 비트 코인에 사용 된 수학을 설명합니다. 다음으로 키 생성, 저장 및 관리 방법을 살펴 보겠습니다. 개인 및 공개 키, 주소 및 스크립트 주소를 나타내는 데 사용되는 다양한 인코딩 형식을 검토합니다. 마지막으로 키와 주소의 고급 사용법을 살펴 보겠습니다 : 허영, 다중 서명, 스크립트 주소 및 종이 지갑.

==== 공개 키 암호화 및 암호 해독

((("keys and addresses", "overview of", "public key cryptography")))((("digital currencies", "cryptocurrency")))공개 키 암호 법은 1970 년대에 발명되었으며, 다음과 같은 수학적 기반을 제공합니다. (( "키와 주소", "개요", "공개 키 암호화" 컴퓨터 및 정보 보안.

공개 키 암호화의 발명 이후로, 소수의 지수 및 타원 곡선의 곱셈과 같은 몇 가지 적합한 수학 함수가 발견되었습니다. 이 수학 함수는 실제적으로 돌이킬 수 없기 때문에 한 방향으로 계산하기 쉽고 반대 방향으로 계산할 수 없다는 것을 의미합니다. 이러한 수학적 기능을 기반으로하는 암호화는 디지털 비밀 및 위조 불가능한 디지털 서명의 생성을 가능하게합니다. Bitcoin은 타원 곡선 곱셈을 암호화의 기초로 사용합니다.
 
비트 코인에서는 공개 키 암호화를 사용하여 비트 코인에 대한 액세스를 제어하는 ​​키 쌍을 만듭니다. 키 쌍은 개인 키와 고유 한 공개 키로 구성됩니다. 공개 키는 자금을 수신하는 데 사용되며, 개인 키는 자금을 보내기 위해 트랜잭션에 서명하는 데 사용됩니다.

공개 키와 개인 키 사이에 수학적 관계가있어 개인 키를 사용하여 메시지에 대한 서명을 생성 할 수 있습니다. 이 서명은 개인 키를 공개하지 않고 공개 키에 대해 유효성을 검사 할 수 있습니다.

비트 코인을 소비 할 때, 현재 비트 코인 소유자는 거래에서 자신의 공개 키와 서명 (매번 다르지만 동일한 개인 키로 생성)을 비트 코인을 사용하여 제공합니다. 공개 키와 서명을 통해 비트 코인 네트워크의 모든 사람이 거래를 유효한지 확인하고 받아 들일 수 있으며 비트 코인을 이전 한 사람이 이전시이를 소유했음을 확인할 수 있습니다.

[팁]
====
((("keys and addresses", "overview of", "key pairs")))대부분의 지갑 구현에서 개인 키와 공개 키는 편의상 _ 키 쌍으로 함께 저장됩니다. 그러나 공개 키는 개인 키로부터 계산 될 수 있으므로 개인 키만 저장하는 것도 가능합니다.
====

[[private_public_keys]]
==== 개인 키와 공개 키

((("keys and addresses", "overview of", "private and public key pairs")))((("elliptic curve cryptography")))((("cryptography", "elliptic curve cryptography"))) 비트 코인 지갑은 개인 키와 공개 키로 구성된 키 쌍 모음을 포함합니다. 개인 키 (k)는 보통 임의로 선택되는 숫자입니다. 개인 키에서 우리는 공개 키 (K)를 생성하기 위해 단방향 암호 함수 인 타원 곡선 곱셈을 사용합니다. 공개 키 (K)로부터, 우리는 비트 코인 어드레스 (A)를 생성하기 위해 단방향 암호화 해시 함수를 사용한다. 이 섹션에서는 개인 키 생성, 공개 키로 변환하는 데 사용되는 타원 곡선 수학을 살펴보고 마지막으로 공개 키로부터 비트 코인 주소를 생성합니다. 개인 키, 공개 키 및 비트 코인 주소 간의 관계는 << k_to_K_to_A >>에 표시됩니다.

[[k_to_K_to_A]]
.개인 키, 공개 키 및 비트 코인 주소
image::images/mbc2_0401.png["privk_to_pubK_to_addressA"]

.왜 비대칭 암호화 (공용 / 개인 키)를 사용합니까?
****
((("cryptography", "asymmetric")))((("digital signatures", "asymmetric cryptography and")))((("asymmetric cryptography")))비트 코 인에서 비대칭 암호화가 사용되는 이유는 무엇입니까? (( "암호화", "비대칭")))) (( "디지털 서명", "비대칭 암호화 및" 트랜잭션을 "암호화"(비밀 유지)하는 데 사용되지 않습니다. 오히려 비대칭 암호화의 유용한 속성은 _digital 서명을 생성하는 기능입니다. 개인 키는 트랜잭션의 디지털 지문에 적용되어 숫자 서명을 생성 할 수 있습니다. 이 서명은 개인 키에 대한 지식이있는 사람 만 생성 할 수 있습니다. 그러나 공개 키 및 트랜잭션 지문에 액세스 할 수있는 사용자는 서명을 _verify_ 할 수 있습니다. 이 비대칭 암호화의 유용한 특성은 모든 트랜잭션에서 모든 서명을 검증 할 수 있으며 개인 키 소유자 만 유효한 서명을 생성 할 수 있습니다.
****

[[private_keys]]
==== 개인 키

((("keys and addresses", "overview of", "private key generation")))((("warnings and cautions", "private key protection")))개인 키는 단순히 숫자이며 무작위로 선택한 것입니다 (( "(키 및 주소", "개요", "개인 키 생성")) . 개인 키에 대한 소유권 및 제어는 해당 비트 코인 주소와 관련된 모든 자금에 대한 사용자 제어의 근원입니다. 비공개 키는 거래에서 사용되는 자금의 소유권을 증명함으로써 비트 코인을 보내는 데 필요한 서명을 만드는 데 사용됩니다. 제 3 자에게 공개하는 것은 해당 키로 보호되는 비트 코인을 제어하는 ​​것과 동일하기 때문에 개인 키는 항상 비밀로 유지되어야합니다. 개인 키는 또한 분실되었을 경우 복구 할 수 없으므로 개인 키가 우발적으로 손실되지 않도록 보호해야합니다.

[팁]
====
bitcoin 개인 키는 숫자입니다. 동전, 연필 및 종이만으로 개인 키를 무작위로 선택할 수 있습니다. 동전을 256 번 던져서 비트 동전 지갑에 사용할 수있는 임의의 개인 키의 이진수를 갖습니다. 그런 다음 개인 키로 공개 키를 생성 할 수 있습니다.
====

===== 난수에서 개인 키 생성하기

키를 생성하는 가장 중요한 첫 번째 단계는 안전한 엔트로피 소스 또는 임의성을 찾는 것입니다. 비트 코인 키 생성은 기본적으로 "1과 2 ^ 256 ^ 사이의 숫자 선택"과 같습니다. 이 번호를 선택하는 데 사용하는 정확한 방법은 예측할 수 없거나 반복 할 수없는 한 중요하지 않습니다. Bitcoin 소프트웨어는 기본 운영 체제의 난수 생성기를 사용하여 256 비트의 엔트로피 (임의성)를 생성합니다. 일반적으로 OS 난수 생성기는 사람이 임의로 생성 한 소스에 의해 초기화되므로 몇 초 동안 마우스를 움직이게 할 수 있습니다.

좀 더 정확히 말하면, 개인 키는 +1 +와 + n - 1 + 사이의 임의의 숫자 일 수 있습니다. 여기서 n은 (n = 1.158 * 10 ^ 77 ^, 2 ^ 256 ^ 비트 코인에서 사용되는 타원 곡선 (<< elliptic_curve >> 참조). 이러한 키를 생성하기 위해 256 비트 숫자를 임의로 선택하여 + n - 1 +보다 작은 지 확인합니다. 프로그래밍 측면에서 보면 암호화 된 보안 랜덤 소스에서 수집 한 더 큰 비트의 랜덤 비트를 SHA256 해시 알고리즘에 제공하면 편리하게 256 비트 숫자를 생성 할 수 있습니다. 결과가 + n - 1+보다 작 으면 적합한 개인 키가 있습니다. 그렇지 않으면 다른 임의의 숫자로 다시 시도하기 만하면됩니다.

[경고]
====
((("random numbers", "random number generation")))((("entropy", "random number generation")))임의의 숫자를 만들거나 "간단한"난수를 사용하는 코드를 작성하지 마십시오 (( "("난수 ","난수 생성 "))) 발전기를 프로그래밍 언어로 제공합니다. 충분한 엔트로피의 소스로부터의 시드와 함께 암호로 안전한 의사 난수 생성기 (CSPRNG)를 사용하십시오. 암호로 안전하다는 것을 확인하기 위해 선택한 난수 생성기 라이브러리의 문서를 연구하십시오. CSPRNG의 올바른 구현은 키 보안에 중요합니다.
====

다음은 임의로 생성 된 개인 키 (k)로, 16 진수 형식으로 표시됩니다 (256 비트는 64 비트 16 진수로 표시, 각 4 비트).

----
1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD
----


[팁]
====
비트 코인의 개인 키 공간 크기 (2 ^ 256 ^)는 아주 큰 숫자입니다. 십진수로 약 10 ^ 77 ^입니다. 비교를 위해, 보이는 우주는 10 ^ 80 ^ 원자를 포함하는 것으로 추정된다.
====

((("dumpprivkey command")))Bitcoin Core 클라이언트 (<< ch03_bitcoin_client >> 참조)에서 새 키를 생성하려면 + getnewaddress + 명령을 사용하십시오. 보안상의 이유로 개인 키가 아닌 공개 키만 표시합니다. + bitcoind +에게 개인 키를 노출하려면 + dumpprivkey + 명령을 사용하십시오. + dumpprivkey + 명령은 개인 키를 _Wallet Import Format_ (WIF)라고하는 Base58 체크섬 인코딩 형식으로 표시합니다.이 형식은 << priv_formats >>에서 자세히 설명합니다. 다음은이 두 명령을 사용하여 개인 키를 생성하고 표시하는 예입니다.

----
$ bitcoin-cli getnewaddress
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
$ bitcoin-cli dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
----

+ dumpprivkey + 명령은 지갑을 열고 + getnewaddress + 명령으로 생성 된 개인용 키를 추출합니다. + bitcoind +가 둘 다 지갑에 저장되어 있지 않으면 공개 키의 개인 키를 알 수 없습니다.

[팁]
==================================================================================================== ===================================================
+ dumpprivkey + 명령은 공개 키에서 개인 키를 생성하지 않습니다. 불가능합니다. 이 명령은 지갑에 이미 알려져 있고 + getnewaddress + 명령으로 생성 된 개인 키를 간단히 표시합니다.
=====================================================================

[role="pagebreak-before"]
Bitcoin Explorer 명령 줄 도구 (<< appdx_bx >> 참조)를 사용하여 + seed +, + ec-new + 및 + ec-to-wif + 명령을 사용하여 개인 키를 생성하고 표시 할 수도 있습니다.

----
$ bx seed | bx ec-new | bx ec-to-wif
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
----

[[pubkey]]
==== 공개 키

((("keys and addresses", "overview of", "public key calculation")))((("generator point")))공개 키는 타원 곡선 곱셈을 사용하여 개인 키에서 계산됩니다.이 곱셈은 돌이킬 수 없게됩니다. (( "키와 주소", "개요", "공개 키 계산" _K_ = _k_ * _G_, 여기서 _k_는 개인 키이고 _G_는 _generator point_라는 상수 점이며 _K_는 결과 공개 키입니다. __K __-을 알고있는 경우 "이산 대수 찾기"로 알려진 역 연산은 _k_의 가능한 모든 값, 즉 무차별 대입 검색을 시도하는 것만큼이나 어렵습니다. 개인 키에서 공개 키를 생성하는 방법을 설명하기 전에 타원 곡선 암호화에 대해 좀 더 자세히 살펴 보겠습니다.

[팁]
====
타원 곡선 곱셈은 암호 작성자가 "트랩 도어"기능이라고 부르는 함수 유형입니다. 한 방향 (곱하기)에서는 수행하기가 쉽고 반대 방향 (나누기)에서는 수행하기가 쉽지 않습니다. 개인 키의 소유자는 공개 키를 쉽게 생성 할 수 있으며 아무도 기능을 되돌릴 수없고 공개 키로 개인 키를 계산할 수 없다는 사실을 알고 공용 키를 쉽게 공유 할 수 있습니다. 이 수학 트릭은 비트 코인 자금의 소유권을 증명하는 위조 불가능하고 안전한 디지털 서명의 기초가됩니다.
====

[[elliptic_curve]]
==== Elliptic Curve Cryptography Explained

((("keys and addresses", "overview of", "elliptic curve cryptography")))((("elliptic curve cryptography", id="eliptic04")))((("cryptography", "elliptic curve cryptography", id="Celliptic04")))타원 곡선 암호는 타원 곡선의 점에 더하기 및 곱하기로 표현되는 이산 대수 문제를 기반으로 한 비대칭 또는 공개 키 암호화 유형입니다.

<< ecc-curve >>는 타원 곡선의 예입니다. 비트 곡선에서 사용되는 것과 유사합니다.

[[ecc-curve]]
[role="smallerthirty"]
.An elliptic curve
image::images/mbc2_0402.png["ecc-curve"]

Bitcoin은 NIST (National Institute of Standard and Technology)에서 제정 한 + secp256k1 +라는 표준에 정의 된대로 특정 타원 곡선과 수학 상수 집합을 사용합니다. + secp256k1 + 곡선은 타원 곡선을 생성하는 다음 함수로 정의됩니다.

[latexmath]
++++
\begin{equation}
{y^2 = (x^3 + 7)}~\text{over}~(\mathbb{F}_p)
\end{equation}
++++

or 

[latexmath]
++++
\begin{equation}
{y^2 \mod p = (x^3 + 7) \mod p}
\end{equation}
++++

_mod p_ (modulo prime number p)는이 곡선이 latexmath로 쓰여진 프라임 오더 _p_의 유한 필드 위에 있음을 나타냅니다. [\ (\ mathbb {F} _p \)], p = 2 ^ 256 ^ - 2 ^ 32 ^ - 2 ^ 9 ^ - 2 ^ 8 ^ -2 ^ 7 ^ - 2 ^ 6 ^ - 2 ^ 4 ^ - 1은 매우 큰 소수입니다.

이 곡선은 실수 대신에 소수 차수의 유한 필드 위에 정의되므로 2 차원으로 흩어져있는 점들의 패턴처럼 보이므로 시각화하기가 어렵습니다. 그러나 수학은 실수에 대한 타원 곡선의 수학과 동일합니다. 예를 들어, << ecc-over-F17- 수학 >>은 프라임 (prime) 17 번 순서의 훨씬 더 작은 유한 필드 위에 동일한 타원 곡선을 보여 주며, 그리드상의 점 패턴을 보여줍니다. + secp256k1 + 비트 코인 타원 곡선은 대단히 큰 격자에서 점들의 훨씬 복잡한 패턴으로 생각할 수 있습니다.

[[ecc-over-F17-math]]
[role="smallersixty"]
.타원 곡선 암호 법 : F (p)에 대한 타원 곡선을 시각화하고, p = 17
image::images/mbc2_0403.png["ecc-over-F17-math"]

예를 들어, 다음은 + secp256k1 + 곡선의 점인 좌표 (x, y)를 갖는 점 P입니다.

----
P = (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424) 
----

<<example_4_1>>은 파이썬을 사용하여 직접 확인하는 방법을 보여줍니다 :

[[example_4_1]]
.파이썬을 사용하여이 점이 타원 곡선에 있음을 확인합니다.
====
[source, pycon]
----
Python 3.4.0 (default, Mar 30 2014, 19:23:13)
[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
>>> x = 55066263022277343669578718895168534326250603453777594175500187360389116729240
>>> y = 32670510020758816978083085130507043184471273380659243275938904335757337482424
>>> (x ** 3 + 7 - y**2) % p
0
----
====

타원 곡선 수학에서 "무한대 점"이라는 점이 있습니다.이 점은 대략 제로의 역할에 해당합니다. 컴퓨터에서 x = y = 0 (타원 곡선 방정식을 만족시키지 않지만 쉽게 확인할 수있는 별개의 사례입니다)으로 표시되는 경우가 있습니다.

또한 "덧셈 (addition)"이라는 패스 : [+] 연산자가 있습니다.이 연산자는 유치원생이 배우는 실수의 전통적인 추가와 유사한 속성을 가지고 있습니다. 타원 곡선에 두 점 P ~ 1 ~ P ~ 2 ~가 주어 졌을 때 타원 곡선에서도 세 번째 점 P ~ 3 ~ P = 1 ~ P ~ 2가있다.

기하학적으로,이 세 번째 점 P ~ 3은 P ~ 1 ~ P ~ 2 사이에 선을 그리면 계산됩니다. 이 선은 정확하게 하나의 추가 위치에서 타원 곡선과 교차합니다. 이 점을 P ~ 3 '= (x, y)라고 부르십시오. 그런 다음 x 축을 반사하여 P ~ 3 = = (x, -y)를 얻습니다.

"무한 점"에 대한 필요성을 설명하는 몇 가지 특별한 경우가 있습니다.

P ~ 1 ~ P ~ 2 ~가 같은 점인 경우, P ~ 1 ~ P ~ 2 ~ 사이의 줄은이 지점 P ~ 1 ~에서 곡선의 접선이되도록 연장되어야합니다. 이 접선은 정확히 하나의 새로운 점에서 곡선을 교차합니다. 미적분의 기법을 사용하여 접선의 기울기를 결정할 수 있습니다. 비록 우리가 두 개의 정수 좌표로 곡선상의 점으로 우리의 관심을 제한하고 있음에도 불구하고,이 기법은 흥미롭게도 작동합니다!

어떤 경우에는 (즉, P ~ 1 ~ P ~ 2 ~ x 값이 같지만 y 값이 다를 경우) 접선이 정확히 수직이됩니다.이 경우 P3 = "무한 점"

P ~ 1 ~이 "무한대 점"이면 P ~ 1 ~ + P ~ 2 ~ = P ~ 2 ~. 유사하게, P ~ 2 -가 무한대에있는 점이면, P ~ 1 ~ + P ~ 2 ~ = P ~ 1 ~. 무한대의 점이 어떻게 0의 역할을하는지 보여줍니다.

그 패스는 다음과 같이 나타납니다 : [+]는 associative입니다. 즉, (A 패스 : [+] B) 패스 : [+] C = A 패스 : [+] (B 패스 : [+] C). 즉 A 패스 : 괄호없이 모호함없이 [+] B 패스 : [+] C를 쓸 수 있습니다.

우리가 추가를 정의 했으므로 추가를 확장하는 표준 방식으로 곱셈을 정의 할 수 있습니다. 타원 곡선상의 점 P에 대해 k가 정수이면 kP = P + P + P + ... + P (k 곱하기). 이 경우 k는 때로는 혼란스럽게 "지수"라고 불립니다.((("", startref="eliptic04")))((("", startref="Celliptic04"))) 

[[public_key_derivation]]
==== 공개 키 생성

((("keys and addresses", "overview of", "public key generation")))((("generator point")))임의로 생성 된 숫자 _k_의 형태로 개인 키로 시작하여, 우리는 그것을 곱한다. (( "키와 주소", "개요", "공개 키 생성"))) _generator point_ _G_라고하는 곡선상의 미리 결정된 점에 의해 곡선상의 다른 점, 즉 대응하는 공개 키 _K_를 생성한다. 생성기 지점은 + secp256k1 + 표준의 일부로 지정되며 bitcoin의 모든 키에 대해 항상 동일합니다.

[latexmath]
++++
\begin{equation}
{K = k * G}
\end{equation}
++++

여기서 _k_는 개인 키이고 _G_은 생성기 지점이며 _K_는 결과 공개 키, 즉 곡선에있는 점입니다. 생성자 포인트는 항상 모든 비트 코인 사용자에게 동일하기 때문에 개인 키 _k_와 _G_를 곱하면 항상 동일한 공개 키 _K_가됩니다. _k_와 _K_ 사이의 관계는 고정되어 있지만 _k_에서 _K_까지 한 방향으로 만 계산할 수 있습니다. 그래서 비트 코인 주소 (_K_에서 파생 됨)를 다른 사람과 공유 할 수 있으며 사용자의 개인 키 (_k_)를 공개하지 않습니다.

[팁]
====
개인 키는 공개 키로 변환 될 수 있지만 공개 키는 개인 키로 다시 변환 될 수 없습니다. 이는 수학이 한 방향으로 만 작동하기 때문입니다.
====

타원 곡선 곱셈을 구현하면 이전에 생성 된 개인 키 _k_를 가져 와서 생성기 점 G와 곱하여 공개 키 _K_를 찾습니다.

----
K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G
----

공개 키 _K_는 점 + K = (x, y) + :

----
K = (x, y) 

where,

x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

점의 정수 곱셈을 시각화하기 위해 실수를 단순화 한 타원 곡선을 사용합니다. 수학은 동일합니다. 우리의 목표는 발전기 지점 _G_의 여러 _kG_를 찾는 것입니다. _G_는 자체에 _G_를 추가하는 것과 동일하며 한 번에 _k_ 번 추가됩니다. 타원 곡선에서 점을 추가하는 것은 점에 접선을 그리고 곡선이 다시 교차하는 위치를 찾은 다음 해당 점을 x 축에 반영하는 것과 같습니다.

<<ecc_illustrated>> 는 커브의 기하 연산으로 _G_, _2G_, _4G_를 유도하는 프로세스를 보여줍니다.

[TIP]
====
((("OpenSSL cryptographic library")))대부분의 비트 코인 구현은 타원 곡선 계산을 수행하기 위해 http://bit.ly/1ql7bn8[OpenSSL 암호화 라이브러리]를 사용합니다. 예를 들어 공개 키를 파생하려면 + EC_POINT_mul () + 함수가 사용됩니다.((("", startref="KAover04")))
====

[[ecc_illustrated]]
.Elliptic curve cryptography: visualizing the multiplication of a point G by an integer k on an elliptic curve
image::images/mbc2_0404.png["ecc_illustrated"]

=== Bitcoin Addresses

((("keys and addresses", "bitcoin addresses", id="KAaddress04")))비트 코인 주소는 돈을 보내려는 사람과 공유 할 수있는 숫자와 문자의 문자열입니다. 공개 키로 생성 된 주소는 "1"로 시작하는 일련의 숫자와 문자로 구성됩니다. 다음은 비트 코인 주소의 예입니다.

----
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
----


비트 코인 주소는 거래에서 자금의 "수신자"로 가장 일반적으로 나타나는 주소입니다. 비트 동전 트랜잭션을 종이 수표와 비교하면 비트 코인 주소가 수익자이며 "주문 지불"후 줄에 쓰는 것입니다. 서류 수표에서 수혜자는 은행 계좌 소유자의 이름 일 수도 있지만 기업, 기관 또는 현금도 포함될 수 있습니다. 서류 수표는 계좌를 지정할 필요가 없기 때문에 추상적 인 이름을 자금 수령인으로 사용하기 때문에 매우 유연한 지불 수단입니다. Bitcoin 트랜잭션은 유사한 추상화 인 비트 코인 (bitcoin) 주소를 사용하여 매우 유연합니다. 비트 코인 주소는 개인 / 공개 키 쌍의 소유자를 나타낼 수 있거나 << p2sh >>에서 볼 수 있듯이 지불 스크립트와 같은 다른 것을 나타낼 수 있습니다. 지금은 단순한 경우 인 공개 키를 나타내는 비트 코인 주소를 살펴 보겠습니다.

((("addresses", "algorithms used to create")))비트 코인 주소는 단방향 암호 해싱을 사용하여 공개 키에서 파생됩니다. "해시 알고리즘"또는 간단히 "해시 알고리즘"은 임의 크기 입력의 지문 또는 "해시"를 생성하는 단방향 함수입니다. 암호화 해시 함수는 비트 코인 (bitcoin) 주소, 스크립트 주소 및 마이닝 (Proof-of-Work) 알고리즘에서 광범위하게 사용됩니다. 공개 키에서 비트 코인 주소를 만드는 데 사용되는 알고리즘은 SHA (Secure Hash Algorithm) 및 RIP 무결성 프리미티브 평가 메시지 요약 (RIPEMD), 특히 SHA256 및 RIPEMD160입니다.

공개 키 _K_로 시작하여 SHA256 해시를 계산 한 다음 결과의 RIPEMD160 해시를 계산하여 160 비트 (20 바이트) 숫자를 생성합니다.

[latexmath]
++++
\begin{equation}
{A = RIPEMD160(SHA256(K))}
\end{equation}
++++

여기서 _K_는 공개 키이고 _A_는 결과 비트 코인 주소입니다.


[TIP]
====
비트 코인 주소는 공개 키와 동일하지 않습니다. Bitcoin 주소는 단방향 함수를 사용하여 공개 키에서 파생됩니다.
====

Bitcoin 주소는 거의 항상 "Base58Check"( "base58"참조)로 인코딩되며, 58 자 (Base58 번호 시스템)와 체크섬을 사용하여 사람의 가독성을 높이고 모호성을 방지하며 주소 변환 및 입력 오류를 방지합니다. Base58Check는 비트 코인 (bitcoin) 주소, 개인 키, 암호화 된 키 또는 스크립트 해시와 같이 숫자를 읽고 바꿔야 할 필요가있을 때마다 비트 코인 (bitcoin)의 다른 많은 방법으로도 사용됩니다. 다음 섹션에서는 Base58Check 인코딩 및 디코딩의 결과와 그에 따른 표현에 대해 살펴 봅니다. << pubkey_to_address >>는 공개 키를 비트 코인 주소로 변환하는 것을 보여줍니다.

[[pubkey_to_address]]
.공개 키를 비트 코인 주소로 변환 : 공개 키를 비트 코인 주소로 변환
image::images/mbc2_0405.png["pubkey_to_address"]

[[base58]]
==== Base58 및 Base58Check 인코딩

((("keys and addresses", "bitcoin addresses", "Base58 and Base58check encoding")))((("Base58 and Base58check encoding", id="base5804")))((("addresses", "Base58 and Base58check encoding", id="Abase5804")))더 적은 수의 심볼을 사용하여 긴 숫자를 간결하게 표현하기 위해 많은 컴퓨터 시스템은 10보다 큰 기본 (또는 기수)이 혼합 된 영숫자 표현을 사용합니다. 예를 들어, 전통적인 10 진수 시스템은 0에서 9까지의 10 개의 숫자를 사용하지만, 16 진수 시스템에서는 A부터 F까지 6 개의 추가 기호로 16을 사용합니다. 16 진수 형식으로 표현 된 숫자는 동등한 10 진수 표현보다 짧습니다. 더 작아 진 Base64 표현은 26 개의 소문자, 26 개의 대문자, 10 개의 숫자 및 & # x201c; '+`& # x201d; 전자 메일과 같은 텍스트 기반 미디어를 통해 이진 데이터를 전송하는 "/". Base64는 전자 메일에 바이너리 첨부 파일을 추가하는 데 가장 일반적으로 사용됩니다. Base58은 비트 코인에서 사용하기 위해 개발 된 텍스트 기반 바이너리 인코딩 형식이며 다른 많은 크립토 통화에서 사용됩니다. 간결한 표현, 가독성 및 오류 감지 및 방지 사이의 균형을 제공합니다. Base58은 대소 문자와 숫자를 사용하는 Base64의 하위 집합이지만 서로 잘못 인식되는 일부 문자는 생략하고 특정 글꼴로 표시 될 때 동일하게 나타날 수 있습니다. 특히 Base58은 0 (숫자 0), O (대문자 o), l (아래쪽 L), I (대문자 i) 및 기호 & # x201c; '+`& # x201d; 및 "/". 또는, 더 간단히 말하면, 이것은 방금 언급 한 4 개 (0, O, I, I)가없는 소문자 및 대문자와 숫자의 집합입니다. << base58alphabet >>은 전체 Base58 알파벳을 보여줍니다.

[[base58alphabet]]
.Bitcoin's Base58 alphabet
====
----
123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
----
====


오타 또는 전사 오류에 대한 추가 보안 기능을 추가하기 위해 Base58Check는 기본 제공되는 오류 확인 코드가있는 Bitcoin에서 자주 사용되는 Base58 인코딩 형식입니다. 체크섬은 인코딩되는 데이터의 끝 부분에 추가로 4 바이트가 추가됩니다. 체크섬은 인코딩 된 데이터의 해시에서 파생되므로 전송 및 타이핑 오류를 감지하고 방지하는 데 사용할 수 있습니다. Base58Check 코드가 제공되면 디코딩 소프트웨어는 데이터의 체크섬을 계산하여 코드에 포함 된 체크섬과 비교합니다. 두 개가 일치하지 않으면 오류가 발생하고 Base58Check 데이터가 유효하지 않습니다. 이렇게하면 잘못 입력 된 비트 코인 주소가 지갑 소프트웨어에서 유효한 대상으로 허용되지 않으며 그렇지 않으면 자금 손실을 초래할 수있는 오류가 발생하지 않습니다.

데이터 (숫자)를 Base58Check 형식으로 변환하려면 먼저 인코딩 된 데이터 유형을 쉽게 식별 할 수있는 "버전 바이트"라는 데이터에 접두사를 추가합니다. 예를 들어 비트 코인 주소의 경우 접두사는 0 (16 진수는 0x00) 인 반면 개인 키 인코딩시 사용되는 접두사는 128 (16 진수는 0x80)입니다. 공통 버전 접두어 목록은 << base58check_versions >>에 나와 있습니다.

다음으로 "double-SHA"체크섬을 계산합니다. 즉, SHA256 해시 알고리즘을 이전 결과 (접두어 및 데이터)에 두 번 적용합니다.
 
----
체크섬 = SHA256 (SHA256 (접두어 + 데이터))
----

결과 32 바이트 해시 (해시 해시)에서 처음 4 바이트 만 가져옵니다. 이 4 바이트는 오류 검사 코드 또는 체크섬의 역할을합니다. 체크섬은 끝에 연결 (추가)됩니다.

결과는 접두어, 데이터 및 체크섬의 세 항목으로 구성됩니다. 이 결과는 이전에 설명한 Base58 알파벳을 사용하여 인코딩됩니다. << base58check_encoding >>은 Base58Check 인코딩 프로세스를 설명합니다.

[[base58check_encoding]]
.Base58Check 인코딩 : 비트 코인 데이터를 명확하게 인코딩하기위한 버전 58, 버전 및 체크섬 형식
image::images/mbc2_0406.png["Base58CheckEncoding"]

비트 코인에서 사용자에게 제공되는 대부분의 데이터는 Base58Check로 인코딩되어 크기가 작고 읽기 쉽고 오류를 쉽게 감지 할 수 있습니다. Base58Check 인코딩의 버전 접두사는 쉽게 구별 할 수있는 형식을 만드는 데 사용됩니다.이 형식은 Base58Check로 인코딩 된 페이로드의 시작 부분에 Base58로 인코딩 할 때 특정 문자를 포함합니다. 이러한 문자로 인해 인간은 인코딩 된 데이터의 유형과 사용 방법을 쉽게 식별 할 수 있습니다. 예를 들어 Base58Check로 인코딩 된 비트 코인 주소는 Base58Check로 인코딩 된 개인 키 WIF에서 1로 시작하여 5로 시작합니다. 일부 예제 버전 접두사와 결과 Base58 문자는 << base58check_versions >>에 표시됩니다. .

[[base58check_versions]]
.Base58Check version prefix and encoded result examples
[options="header"]
|=======
|Type| Version prefix (hex)| Base58 result prefix
| Bitcoin Address | 0x00 | 1 
| Pay-to-Script-Hash Address | 0x05 | 3 
| Bitcoin Testnet Address | 0x6F | m or n 
| Private Key WIF |  0x80 | 5, K, or L 
| BIP-38 Encrypted Private Key | 0x0142 | 6P 
| BIP-32 Extended Public Key | 0x0488B21E | xpub  
|=======


비공개 키에서 공개 키 (타원 곡선상의 한 점), 이중 해시 주소 및 마지막으로 Base58Check 인코딩에 이르기까지 비트 코인 주소를 만드는 과정을 살펴 보겠습니다. << addr_example >>의 C ++ 코드는 개인 키에서 Base58Check로 인코딩 된 비트 코인 주소까지의 단계별 프로세스를 보여줍니다. 이 코드 예제에서는 << alt_libraries >>에 도입 된 libbitcoin 라이브러리를 사용하여 일부 도우미 함수를 사용합니다.

[[addr_example]]
.Creating a Base58Check-encoded bitcoin address from a private key
====
[source, cpp]
----
include::code/addr.cpp[]
----
====

코드는 << addr_example_run >>과 같이 미리 정의 된 개인 키를 사용하여 실행될 때마다 동일한 비트 코인 주소를 생성합니다 ((("", startref="base5804")))((("", startref="Abase5804")))

[[addr_example_run]]
.Compiling and running the addr code
====
[source,bash]
----
# Compile the addr.cpp code
$ g++ -o addr addr.cpp $(pkg-config --cflags --libs libbitcoin)
# Run the addr executable
$ ./addr
Public key: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa
Address: 1PRTTaJesdNovgne6Ehcdu1fpEdX7913CK
----
====

==== 키 형식

((("keys and addresses", "bitcoin addresses", "key formats")))Both private and public keys can be represented in a number of different formats. These representations all encode the same number, even though they look different. These formats are primarily used to make it easy for people to read and transcribe keys without introducing errors.

[[priv_formats]]
===== Private key formats

((("public and private keys", "private key formats")))개인 키와 공개 키는 다양한 형식으로 표현 될 수 있습니다. 이러한 표현은 모두 다르게 보이지만 동일한 숫자를 모두 인코딩합니다. 이러한 형식은 주로 사람들이 오류를 유발하지 않고 키를 읽고 쉽게 기록하는 데 사용됩니다.

[[table_4-2]]
.Private key representations (encoding formats)
[options="header"]
|=======
|Type|Prefix|Description
| Raw | None | 32 bytes
| Hex | None | 64 hexadecimal digits
| WIF |  5 | Base58Check encoding: Base58 with version prefix of 128- and 32-bit checksum
| WIF-compressed | K or L | As above, with added suffix 0x01 before encoding
|=======

<<table_4-3>> shows the private key generated in these three formats.

[[table_4-3]]
.Example: Same key, different formats
[options="header"]
|=======
|Format | Private key
| Hex | 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 
| WIF | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
| WIF-compressed | KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
|=======

이러한 모든 표현은 같은 번호 인 동일한 개인 키를 보여주는 다른 방법입니다. 그들은 다르게 보일지라도, 어떤 한 포맷도 다른 포맷으로 쉽게 변환 될 수 있습니다. "raw binary"는 << table_4-3 >>에 표시되지 않습니다. 여기에 표시 할 인코딩은 정의에 따라 원시 이진 데이터가 아닙니다.

Bitcoin Explorer에서 + wif-to-ec + 명령을 사용하여 (<< appdx_bx >> 참조) 두 WIF 키가 동일한 개인 키를 나타냄을 나타냅니다.

----
$ bx wif-to-ec 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd

$ bx wif-to-ec KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
----

===== Base58Check에서 디코딩

Bitcoin 탐색기 명령 (<< appdx_bx >> 참조)을 사용하면 비트 코 인 키, 주소 및 트랜잭션을 조작하는 쉘 스크립트 및 명령 줄 "파이프"를 쉽게 작성할 수 있습니다. Bitcoin Explorer를 사용하여 명령 줄에서 Base58Check 형식을 디코딩 할 수 있습니다.

+ base58check-decode + 명령을 사용하여 압축되지 않은 키를 디코딩합니다.

----
$ bx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
wrapper
{
    checksum 4286807748
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
    version 128
}
----

결과에는 페이로드의 키, WIF 버전 접두어 128 및 체크섬이 포함됩니다.

압축 된 키의 "페이로드"에는 접미어 +01+가 추가되어 파생 된 공개 키가 압축되어야 함을 알립니다.

----
$ bx base58check-decode KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
wrapper
{
    checksum 2339607926
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01
    version 128
}
----

===== 16 진수에서 Base58Check로 인코딩

Base58Check (이전 명령과 반대)로 인코딩하려면 Bitcoin Explorer (+ appdx_bx >> 참조)에서 + base58check-encode + 명령을 사용하고 16 진수 개인 키와 WIF 버전 접두사 128을 입력하십시오.

----
bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd --version 128
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
----

===== 16 진수 (압축 된 키)에서 Base58Check로 인코딩

Base58Check를 "압축 된"개인 키 (<< comp_priv >> 참조)로 인코딩하려면 접미어 +01+를 16 진수 키에 추가 한 다음 앞 절에서와 같이 인코딩합니다.

----
$ bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 --version 128
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
----

결과 WIF 압축 형식은 "K"로 시작합니다. 이것은 내부의 개인 키가 "01"접미어를 가지며 압축 된 공개 키만 생성하는 데 사용됨을 나타냅니다 (<< comp_pub >> 참조).

===== 공개 키 형식

((("public and private keys", "public key formats")))공개 키는 다른 방법으로 제공되며 보통 _compressed_ 또는 _uncompressed_ 공개 키로 사용됩니다.

이전에 보았 듯이 공개 키는 좌표 쌍 + (x, y) +로 구성된 타원 곡선상의 한 점입니다. 대개 접두어 +04 + 다음에 두 개의 256 비트 숫자가 붙습니다. 하나는 점의 _x_ 좌표 용이고 다른 하나는 _y_ 좌표 용입니다. 접두사 +04+는 압축되지 않은 공개 키와 +02 + 또는 +03 +로 시작하는 압축 공개 키를 구별하는 데 사용됩니다.

다음은 이전에 생성 한 개인 키에 의해 생성 된 공개 키입니다 (좌표 + x + 및 + y +로 표시됨).

----
x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

다음은 접두어 +04+ 뒤에 + x +와 + y + 좌표가있는 520 비트 숫자 (130 자리 16 진수)로 표시되는 동일한 공개 키입니다 (예 : +04 x y +).

++++
<pre data-type="programlisting">
K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A&#x21b5;
07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
</pre>
++++

[[comp_pub]]
[role="pagebreak-before"]
===== 압축 된 공개 키

((("public and private keys", "compressed public keys")))비트 코인 블록 체인 데이터베이스를 저장하는 노드에서 트랜잭션 크기를 줄이고 디스크 공간을 절약하기 위해 압축 공개 키가 도입되었습니다. 대부분의 거래에는 소유자의 자격 증명을 확인하고 비트 동전을 소비하는 데 필요한 공개 키가 포함됩니다. 각 공개 키는 520 비트 (접두어 + x + y)를 필요로하며, 블록 당 수 백 건의 거래 또는 하루에 수십만 건의 트랜잭션을 곱하면 블록 체인에 상당한 양의 데이터가 추가됩니다.

<< pubkey >> 섹션에서 보았 듯이, 공개 키는 타원 곡선상의 점 (x, y)입니다. 곡선은 수학 함수를 표현하기 때문에 곡선의 한 점은 방정식의 해를 나타냅니다. 따라서 _x_ 좌표를 알면 방정식 y ^ 2 ^ mod p = (x ^ 3)을 풀어서 _y_ 좌표를 계산할 수 있습니다 ^ + 7) mod p. 이를 통해 공개 키 포인트의 _x_ 좌표 만 저장하고 _y_ 좌표는 생략하고 키의 크기와 키를 256 비트 씩 저장하는 데 필요한 공간을 줄입니다. 모든 거래에서 크기를 거의 50 % 줄이면 시간이 지남에 따라 저장된 많은 데이터가 추가됩니다!

압축되지 않은 공개 키는 +04+의 접두사를 갖지만 압축 된 공개 키는 +02+ 또는 +03+ 접두사로 시작합니다. 두 가지 가능한 접두어가있는 이유를 살펴 보겠습니다. 방정식의 왼쪽이 __y __ ^ 2 ^이므로 __y_의 해는 제곱근이며 양수 또는 음수 값을 가질 수 있습니다. 시각적으로, 이는 _y_ 좌표가 x 축 위 또는 아래 일 수 있음을 의미합니다. << ecc-curve >>의 타원 곡선의 그래프에서 알 수 있듯이 커브는 대칭입니다. 즉, x 축에 의해 거울처럼 반사됩니다. 따라서 우리는 _y_ 좌표를 생략 할 수 있지만 _y_ _____ (양수 또는 음수)를 저장해야합니다. 다른 말로하면 x 축의 위 또는 아래에 있는지 여부를 기억해야합니다. 각 옵션은 다른 점과 다른 공개 키를 나타 내기 때문입니다. 프라임 순서 p의 유한 필드에서 이진 산술로 타원 곡선을 계산할 때 _y_ 좌표는 앞에서 설명한 바와 같이 양 / 음 기호에 해당하는 짝수 또는 홀수 중 하나입니다. 따라서 _y_의 가능한 두 값을 구별하기 위해 _y_가 짝수이면 접두사 +02+, 홀수 인 경우 +03+가있는 압축 된 공개 키를 저장하여 소프트웨어가 _y_ 좌표를 올바르게 추측 할 수있게합니다. _x_ 좌표를 지정하고 공개 키를 해당 점의 전체 좌표로 압축 해제합니다. 공개 키 압축은 << pubkey_compression >>에 설명되어 있습니다.

[[pubkey_compression]]
[role="smallerseventy"]
.Public key compression
image::images/mbc2_0407.png["pubkey_compression"]

이전에 생성 된 동일한 공개 키가 264 비트 (66 진수)로 저장된 압축 공개 키로 표시되며 접두사 +03+은 _y_ 좌표가 홀수임을 나타냅니다.

----
K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
----

이 압축 공개 키는 동일한 개인 키에 해당합니다. 즉, 동일한 개인 키에서 생성됩니다. 그러나 압축되지 않은 공개 키와는 모양이 다릅니다. 더 중요한 것은 double-hash 함수 (+ RIPEMD160 (SHA256 (K)) +)를 사용하여 압축 된 공개 키를 비트 코인 주소로 변환하면 _different_ 비트 코인 주소가 생성된다는 것입니다. 이것은 하나의 개인 키가 두 개의 서로 다른 비트 코인 주소를 생성하는 두 가지 다른 형식 (압축 및 비 압축)으로 표현 된 공개 키를 생성 할 수 있기 때문에 혼란 스러울 수 있습니다. 그러나 개인 키는 양쪽 비트 코인 주소가 동일합니다.

압축 된 공개 키는 점차적으로 비트 퀀 클라이언트의 기본값이되어 트랜잭션 크기를 줄이는 데 중요한 영향을 미치므로 블록 체인을 줄입니다. 그러나 모든 클라이언트가 압축 된 공개 키를 아직 지원하지는 않습니다. 압축 된 공개 키를 지원하는 최신 클라이언트는 압축 된 공개 키를 지원하지 않는 이전 클라이언트의 트랜잭션을 고려해야합니다. 이것은 지갑 응용 프로그램이 다른 비트 코인 지갑 응용 프로그램에서 개인 키를 가져 오는 경우 특히 중요합니다. 새 지갑은 이러한 가져온 키에 해당하는 트랜잭션을 찾기 위해 블록 체인을 검사해야하기 때문입니다. 비트 코인 지갑에서 어떤 비트 코인 주소를 스캔해야합니까? 압축되지 않은 공개 키 또는 압축 된 공개 키에 의해 생성 된 비트 코인 주소로 생성 된 비트 코인 주소? 둘 다 유효한 비트 코인 주소이며 개인 키로 서명 할 수 있지만 주소는 다릅니다!

이 문제를 해결하기 위해 개인 키를 지갑에서 내 보낸 경우이를 나타내는 데 사용되는 WIF가 최신 비트 동전 지갑에서 다르게 구현되어 이러한 개인 키가 _ 압축 _ 공개 키를 생성하고 _compressed_ bitcoin 주소를 생성하는 데 사용되었음을 나타냅니다. 이를 통해 가져 오는 지갑은 이전 또는 이후의 지갑에서 가져온 개인 키를 구별하고 블록 체인에서 비 압축 또는 압축 된 공개 키에 해당하는 비트 코인 주소로 트랜잭션을 검색 할 수 있습니다. 다음 섹션에서 이것이 어떻게 작동하는지 자세히 살펴 보겠습니다.

[[comp_priv]]
===== Compressed private keys

((("public and private keys", "compressed private keys")))아이러니 컬하게도 압축 개인 키라는 용어는 잘못된 이름입니다. 왜냐하면 개인 키가 WIF 압축으로 내보내지면 실제로는 1 바이트보다 길기 때문입니다 (압축 된 개인 키). "비 압축"개인 키. 이는 개인 키가 추가 된 1 바이트 접미사 (<< table_4-4 >>에서 16 진수로 01로 표시됨)를 가지므로 비공개 키가 최신 지갑에서 왔음을 나타내며 압축 된 공개 키를 생성하는 데에만 사용해야합니다 . 개인 키는 압축되지 않으며 압축 할 수 없습니다. "압축 된 개인 키"라는 용어는 실제로 "압축 된 공개 키만 파생되어야하는 개인 키"를 의미하지만 "압축되지 않은 개인 키"는 실제로 "압축되지 않은 공개 키만 파생되어야하는 개인 키"를 의미합니다. 내보내기 형식을 "WIF- 압축"또는 "WIF"로만 참조하고 혼동을 피하기 위해 개인 키 자체를 "압축"으로 나타내지 않아야합니다

<< table_4-4 >>는 WIF 및 WIF 압축 형식으로 인코딩 된 동일한 키를 보여줍니다.

[[table_4-4]]
.Example: Same key, different formats
[options="header"]
|=======
|Format | Private key
| Hex | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD
| WIF | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
| Hex-compressed | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01
| WIF-compressed | KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
|=======

16 진수로 압축 된 개인 키 형식의 끝에는 1 바이트의 추가 바이트가 있습니다 (16 진수는 01). Base58 인코딩 버전 접두어가 WIF 및 WIF 압축 형식 모두에 대해 (0x80) 동일하지만 숫자 끝에 하나의 바이트를 추가하면 Base58 인코딩의 첫 문자가 5에서 _K_ 또는 _엘_. 이 값을 100과 99 사이의 10 진수 인코딩 차이의 Base58에 해당한다고 생각하십시오. 100은 99보다 한 자릿수가 길지만 접두어 대신 9의 접두사가 붙습니다. 길이가 변경되면 접두어에 영향을줍니다. Number58의 길이가 1 바이트 증가함에 따라 Base58에서 접두어 5는 _K_ 또는 _L_으로 변경됩니다.

이러한 형식은 서로 호환되어 사용되는 것은 아닙니다. 압축 된 공개 키를 구현하는 새 Wallet에서는 개인 키가 WIF로 압축되어 (_K_ 또는 _L_ 접두어로) 내 보낸 것입니다. Wallet이 구형 구현이며 압축 된 공개 키를 사용하지 않는 경우 개인 키는 WIF (접두사 5)로만 내보낼 수 있습니다. 여기서 목표는 압축 또는 비공개 공개 키와 주소에 대한 블록 체인을 검색해야하는지 여부와 상관없이 이러한 개인 키를 가져 오는 지갑에 신호를 보내는 것입니다.

비트 코인 지갑이 압축 된 공개 키를 구현할 수있는 경우 모든 트랜잭션의 키를 사용합니다. 지갑의 개인 키는 압축 될 커브의 공개 키 포인트를 유도하는 데 사용됩니다. 압축 된 공개 키는 비트 코인 (bitcoin) 주소를 생성하는 데 사용되며 트랜잭션에 사용됩니다. 압축 공개 키를 구현하는 새 지갑에서 개인 키를 내보낼 때 개인 키에 1 바이트 접미사 +01+가 추가되어 WIF가 수정됩니다. 생성 된 Base58Check로 인코딩 된 개인 키는 "압축 된 WIF"라고하며 이전 지갑의 WIF로 인코딩 된 (비 압축) 키의 경우와 같이 "5"로 시작하는 대신 _K_ 또는 _L_로 시작합니다.


[팁]
====
"압축 개인 키"는 잘못된 이름입니다! 그들은 압축되지 않습니다; 오히려 WIF 압축은 키가 압축 된 공개 키와 해당 비트 코인 주소를 파생시키는 데에만 사용해야한다는 것을 나타냅니다. 역설적이게도 "압축 해제 된"개인 키와 구별하기 위해 추가 된 +01+ 접미사가 있기 때문에 "WIF 압축 된"개인 키는 1 바이트 더 길어집니다 ((("", startref="KAaddress04")))
====

=== 파이썬에서 키와 주소 구현하기

((("keys and addresses", "implementing in Python", id="KApython04")))((("pybitcointools")))파이썬에서 가장 포괄적 인 bitcoin 라이브러리는 https://github.com/vbuterin/입니다. (( "키와 주소", "파이썬에서 구현", id = "KApython04" Vitalik Buterin의 pybitcointools [pybitcointools]. << key-to-address_script >>에서 우리는 다양한 형식의 키와 주소를 생성하고 표시하는 pybitcointools 라이브러리 (비트 코인으로 가져옴)를 사용합니다.

[[key-to-address_script]]
.Key and address generation and formatting with the pybitcointools library
====
[source,python]
----
include::code/key-to-address-ecc-example.py[]
----
====

<<key-to-address_script_run>> shows  the output from running this code.

[[key-to-address_script_run]]
.Running key-to-address-ecc-example.py
====
++++
<pre data-type="programlisting">
$ python key-to-address-ecc-example.py 
Private Key (hex) is:  
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6
Private Key (decimal) is:  
 26563230048437957592232553826663696440606756685920117476832299673293013768870
Private Key (WIF) is:  
 5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4K
Private Key Compressed (hex) is:  
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601
Private Key (WIF-Compressed) is:  
 KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6S
Public Key (x,y) coordinates is: 
 (41637322786646325214887832269588396900663353932545912953362782457239403430124L, 
 16388935128781238405526710466724741593761085120864331449066658622400339362166L)
Public Key (hex) is: 
 045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec&#x21b5;
243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176
Compressed Public Key (hex) is: 
 025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec
Bitcoin Address (b58check) is: 
 1thMirt546nngXqyPEz532S8fLwbozud8
Compressed Bitcoin Address (b58check) is: 
 14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3
</pre>
++++
====


<< ec_math >>는 타원 곡선 수학을 위해 그리고 특별한 bitcoin 라이브러리를 사용하지 않고 파이썬 ECDSA 라이브러리를 사용하는 또 다른 예입니다.

[[ec_math]]
.비트 코 키에 사용되는 타원 곡선 수학을 보여주는 스크립트.
====
[source, python]
----
include::code/ec-math.py[]
----
====

<<ec_math_run>> shows the output produced by running this script.

[NOTE]
====
<<ec_math>> ((("random numbers", "os.urandom", see="entropy")))((("entropy", "os.urandom", see="random numbers")))((("random numbers", "random number generation")))((("entropy", "random number generation")))은 + os.urandom +을 사용하며, 이는 암호로 안전한 CSRNG (난수 생성기)를 반영합니다. 기본 운영 체제. 리눅스와 같은 유닉스 계열의 운영체제의 경우, + / dev / urandom +; Windows의 경우 + CryptGenRandom () +을 호출합니다. 적절한 임의성 소스가 발견되지 않으면 + NotImplementedError +가 발생합니다. 여기에 사용 된 난수 생성기는 데모 용이지만, 충분한 보안으로 구현되지 않았으므로 프로덕션 품질 비트 코닉 키를 생성하는 데 적합하지 않습니다. ((("", startref="KApython04")))
====

[[ec_math_run]]
.Python ECDSA 라이브러리 설치 및 ec_math.py 스크립트 실행
====
----
$ # Install Python PIP package manager
$ sudo apt-get install python-pip
$ # Install the Python ECDSA library
$ sudo pip install ecdsa
$ # Run the script
$ python ec-math.py 
Secret:  38090835015954358862481132628887443905906204995912378278060168703580660294000
EC point: (70048853531867179489857750497606966272382583471322935454624595540007269312627, 105262206478686743191060800263479589329920209527285803935736021686045542353380)
BTC public key: 029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873
----
====

=== 고급 키 및 주소

((("keys and addresses", "advanced forms", id="KAadvanced04")))다음 섹션에서는 암호화 된 개인 키, 스크립트 및 다중 서명 주소, 장식용 주소 (vanity address)와 같은 고급 형식의 키 및 주소를 살펴볼 것입니다

==== 암호화 된 개인 키 (BIP-38)

((("bitcoin improvement proposals", "Encrypted Private Keys (BIP-38)")))((("keys and addresses", "advanced forms", "encrypted private keys")))((("public and private keys", "encrypted private keys")))((("passwords", "encrypted private keys")))((("security", "passwords")))개인 키 ","암호화 된 개인 키 "))) (("비밀번호 ","암호화 된 개인 키 "))) (("보안 ","비밀번호 ")) 개인 키는 비밀로 유지해야합니다. 비공개 키의 _ 기밀성에 대한 필요성은 동등하게 중요한 보안 목적 인 _ 가용성 _과 충돌하기 때문에 실제로 달성하기는 매우 쉬운 진실입니다. 비공개 키를 비공개로 유지하는 것은 비공개 키의 백업을 저장해야 손실 될 염려가 있습니다. 지갑에 저장된 개인 키는 암호로 암호화되어 안전하지만 지갑을 백업해야합니다. 때때로 사용자는 예를 들어 지갑 소프트웨어를 업그레이드하거나 교체하기 위해 하나의 지갑에서 다른 지갑으로 키를 이동해야합니다. 개인 키 백업은 종이 (<< paper_wallets >> 참조) 또는 USB 플래시 드라이브와 같은 외부 저장 미디어에 저장 될 수도 있습니다. 그러나 백업 자체가 도난 당했거나 유실 된 경우에는 어떻게해야합니까? 이러한 상충되는 보안 목표는 BIP-38 ( "appdxbitcoinimpproposals"참조)이 표준화 한 다양한 지갑 및 비트 코인 클라이언트가 이해할 수있는 방식으로 개인 키를 암호화하기위한 이식 가능한 편리한 표준을 도입하게되었습니다.
    
BIP-38은 개인 키를 암호문으로 암호화하고 Base58Check로 인코딩하여 백업 미디어에 안전하게 저장하거나 지갑간에 안전하게 전송하거나 키가 노출 될 수있는 다른 조건에서 보관할 수있는 공통 표준을 제안합니다. 암호화 표준은 NIST에서 제정 한 표준 인 AES (Advanced Encryption Standard)를 사용하며 상업용 및 군사용 데이터 암호화 구현에 광범위하게 사용됩니다.

BIP-38 암호화 체계는 일반적으로 WIF로 인코딩 된 bitcoin 개인 키를 접두어가 "5"인 Base58Check 문자열로 입력으로 사용합니다. 또한 BIP-38 암호화 체계는 일반적으로 여러 단어 또는 영숫자 문자로 구성된 긴 암호 인 암호를 사용합니다. BIP-38 암호화 체계의 결과는 접두사 + 6P +로 시작하는 Base58Check 인코딩 암호화 된 개인 키입니다. + 6P +로 시작하는 키가 보이면 암호로 암호화되어 지갑에서 사용할 수있는 WIF 형식의 개인 키 (접두어 +5+)로 다시 변환 (암호 해독)해야합니다. 많은 지갑 응용 프로그램이 이제 BIP-38로 암호화 된 개인 키를 인식하고 사용자에게 키를 해독하고 가져 오기위한 암호 문구를 입력하라는 메시지를 표시합니다. 매우 유용한 브라우저 기반 http://bitaddress.org [Bit Address] (Wallet Details 탭)와 같은 타사 응용 프로그램을 사용하여 BIP-38 키의 암호를 해독 할 수 있습니다.

BIP-38 암호화 키의 가장 일반적인 사용 사례는 종이에 개인 키를 백업하는 데 사용할 수있는 종이 지갑입니다. 사용자가 강력한 암호 문구를 선택하는 경우 BIP-38 암호화 된 개인 키가있는 종이 지갑은 매우 안전하며 오프라인 비트 코인 저장소 ( "콜드 스토리지"라고도 함)를 만들 수있는 좋은 방법입니다.

<< table_4-10 >>의 암호화 된 키를 bitaddress.org를 사용하여 테스트하여 암호문을 입력하여 해독 된 키를 가져 오는 방법을 확인하십시오.

[[table_4-10]]
.Example of BIP-38 encrypted private key 
|=======
| *Private Key (WIF)* | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
| *Passphrase* | MyTestPassphrase
| *Encrypted Key (BIP-38)* | 6PRTHL6mWa48xSopbU1cKrVjpKbBZxcLRRCdctLJ3z5yxE87MobKoXdTsJ
|=======


[[p2sh_addresses]]
==== Pay-to-Script Hash (P2SH) and Multisig Addresses 

((("keys and addresses", "advanced forms", "pay-to-script hash and multisig addresses")))((("Pay-to-Script-Hash (P2SH)", "multisig addresses and")))((("multisig addresses")))((("addresses", "multisig addresses")))우리가 알다시피 전통적인 비트 코인 주소는 숫자 "1"로 시작하여 공개 키에서 파생됩니다. 개인 키에서 파생됩니다. 누구나 비트 코인을 "1"주소로 보낼 수 있지만 비트 코인은 해당 개인 키 서명과 공개 키 해시를 제시해야만 사용할 수 있습니다.

숫자 3으로 시작하는 비트 코인 주소는 P2SH (pay-to-script hash) 주소이며 때로는 잘못 다중 시그널이라고도합니다. 또는 ( "("비트 코인 개선 제안 ","Pay To Script Hash (BIP-16) "))) 다중 주소. 그들은 공개 키의 소유자가 아니라 스크립트의 해시로서 비트 코인 트랜잭션의 수혜자를 지정합니다. 이 기능은 2012 년 1 월 BIP-16 (<< appdxbitcoinimpproposals >> 참조)과 함께 도입되었으며 주소 자체에 기능을 추가 할 수있는 기회를 제공하기 때문에 널리 채택되고 있습니다. "3"주소로 전송 된 자금은 공개 키 해시 (P2PKH)라고도하는 기존의 "1"비트 코인 주소로 자금을 "보내는"트랜잭션과 달리 하나의 공개 키 해시 소유권을 입증하는 하나의 개인 키 서명 요구 사항은 주소가 생성 될 때 스크립트 내에서 지정되며이 주소에 대한 모든 입력은 동일한 요구 사항으로 인해 제한됩니다.
    
P2SH 주소는 누가 트랜잭션 출력을 보낼 수 있는지 정의하는 트랜잭션 스크립트 (자세한 내용은 << p2sh >> 참조)에서 생성됩니다. P2SH 주소 인코딩에는 비트 동전 주소를 만드는 동안 사용 된 것과 동일한 이중 해시 함수를 사용하는 것이 포함되며, 공개 키 대신 스크립트에만 적용됩니다.
    
----
script hash = RIPEMD160(SHA256(script))
----
    
결과 "스크립트 해시"는 버전 접두사가 5 인 Base58Check로 인코딩되어 +3+로 시작하는 인코딩 된 주소가됩니다. P2SH 주소의 예는 다음과 같이 Bitcoin Explorer 명령 + script-encode +, + sha256 +, + ripemd160 + 및 + base58check-encode + (<< appdx_bx >> 참조)를 사용하여 파생 될 수있는 + 3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM +입니다.

----
$ echo dup hash160 [ 89abcdefabbaabbaabbaabbaabbaabbaabbaabba ] equalverify checksig > script
$ bx script-encode < script | bx sha256 | bx ripemd160 | bx base58check-encode --version 5
3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM
----

[팁]
====
P2SH는 다중 시그널 표준 트랜잭션과 반드시 ​​같을 필요는 없습니다. P2SH 주소 _most often_는 다중 서명 스크립트를 나타내지 만 다른 유형의 트랜잭션을 인코딩하는 스크립트를 나타낼 수도 있습니다.
====

===== 다중 서명 주소 및 P2SH

현재 P2SH 기능의 가장 일반적인 구현은 다중 서명 주소 스크립트입니다. 이름에서 알 수 있듯이 기본 스크립트는 소유권을 증명하고 자금을 지출하기 위해 하나 이상의 서명이 필요합니다. 비트 동전 다중 서명 기능은 M이 N 이하인 M-of-N 다중 서명으로 알려진 총 N 개의 키에서 M 서명 ( "임계 값"이라고도 함)을 요구하도록 설계되었습니다. 예를 들어 << ch01_intro_what_is_bitcoin >>의 찻집 주인 Bob은 자신에게 속한 키의 2 분의 1 서명과 배우자의 키가 필요한 다중 서명 주소를 사용하여 둘 중 하나가 거래 출력을 잠그도록 서명 할 수 있도록 할 수 있습니다 이 주소로. 이것은 배우자가 단일 서명으로 지출 할 수있는 전통적인 은행 업무에서 구현 된 "공동 계좌"와 유사합니다. 또는 웹 사이트를 만들기 위해 Bob이 지불 한 웹 디자이너 인 Gopesh ((( "유스 케이스", "해외 계약 서비스"))는 자금이 없을 수 있음을 보장하는 사업용으로 2/3 다중 서명 주소를 가질 수 있습니다 비즈니스 파트너 중 최소한 두 개가 트랜잭션에 서명하지 않는 한 보냈습니다.

<< 거래 >>에서 P2SH (및 다중 서명) 주소로 자금을 사용하는 거래를 만드는 방법을 모색합니다.

==== Vanity Addresses

((("keys and addresses", "advanced forms", "vanity addresses")))((("vanity addresses", id="vanity04")))((("addresses", "vanity addresses", id="Avanity04")))가상 주소는 사람이 읽을 수있는 메시지가 들어있는 유효한 비트 코인 주소입니다. 예를 들어, + 1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33 +는 처음 네 개의 Base-58 문자로 "Love"라는 단어를 구성하는 문자가 포함 된 유효한 주소입니다. 허영심 주소는 원하는 패턴의 비트 코인 주소가 발견 될 때까지 수십억 개의 후보 개인 키를 생성하고 테스트해야합니다. 허영 생성 알고리즘에는 몇 가지 최적화가 있지만 프로세스는 기본적으로 개인 키를 무작위로 선택하고 공개 키를 파생시키고 비트 코인 주소를 파생시키고 원하는 허영 패턴과 일치하는지 확인하여 수십억 번 반복하여 일치하는 것이 발견되었습니다.

원하는 패턴과 일치하는 가상 주소가 발견되면 해당 주소에서 파생 된 개인 키를 다른 주소와 똑같은 방법으로 소유자가 사용할 수 있습니다. 허영심 주소는 다른 주소보다 덜 안전합니다. 이들은 다른 주소와 동일한 Elliptic Curve Cryptography (ECC) 및 SHA에 의존합니다. 허영 패턴으로 시작하는 주소의 개인 키를 다른 주소보다 쉽게 ​​찾을 수 없습니다.

<< ch01_intro_what_is_bitcoin >>에서는 필리핀에서 활동하는 어린이 자선 사업가 인 Eugenia를 소개했습니다. Eugenia가 비트 코인 기금 모금 운동을 조직하고 기금 모금을 홍보하기 위해 가상의 비트 코인 주소를 사용하려고한다고 가정 해 봅시다. Eugenia는 어린이 기금 모금 행사를 홍보하기 위해 "1Kids"로 시작하는 허영심 주소를 만듭니다. 이 허영심 주소가 어떻게 생성되고 Eugenia의 자선 단체의 안전을 위해 그것이 의미하는지 알아 보겠습니다.((("use cases", "charitable donations", startref="eugeniafour"))) 

===== Generating vanity addresses

비트 코인 주소는 단순히 Base58 알파벳의 기호로 표시된 숫자라는 사실을 깨닫는 것이 중요합니다. '1Kids'와 같은 패턴을 검색하면 + 1Kids11111111111111111111111111111 +에서 +1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz +까지 범위의 주소를 검색하는 것으로 볼 수 있습니다. 해당 범위에는 약 1 2 5 6 ^ (^ 1 ^ 2 ^ 2 ^ 2) 개의 주소가 있으며, 모두 "1 키즈"로 시작합니다. << table_4-11 >>은 접두사가 1Kid 인 주소 범위를 나타냅니다.

[[table_4-11]]
.The range of vanity addresses starting with "1Kids"
|=======
| *From* | +1Kids11111111111111111111111111111+
| | +1Kids11111111111111111111111111112+
| | +1Kids11111111111111111111111111113+
| | +...+
| *To* | +1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz+
|=======

"1Kids"패턴을 숫자로보고 비트 동전 주소에서이 패턴을 찾을 수있는 빈도를 봅시다 (<< table_4-12 >> 참조). 특수한 하드웨어가없는 일반 데스크탑 컴퓨터 PC는 초당 약 100,000 개의 키를 검색 할 수 있습니다.

[[table_4-12]]
.The frequency of a vanity pattern (1KidsCharity) and average search time on a desktop PC
[options="header"]
|=======
| Length | Pattern | Frequency | Average search time
| 1 | 1K | 1 in 58 keys | < 1 milliseconds
| 2 | 1Ki| 1 in 3,364 | 50 milliseconds 
| 3 | 1Kid | 1 in 195,000 | < 2 seconds
| 4 | 1Kids | 1 in 11 million | 1 minute
| 5 | 1KidsC | 1 in 656 million | 1 hour
| 6 | 1KidsCh | 1 in 38 billion | 2 days
| 7 | 1KidsCha | 1 in 2.2 trillion | 3–4 months
| 8 | 1KidsChar | 1 in 128 trillion | 13–18 years
| 9 | 1KidsChari | 1 in 7 quadrillion | 800 years
| 10 | 1KidsCharit | 1 in 400 quadrillion | 46,000 years
| 11 | 1KidsCharity | 1 in 23 quintillion | 2.5 million years
|=======


보시다시피, Eugenia는 수천 대의 컴퓨터에 액세스 할 수 있더라도 곧바로 가상 주소 "1KidsCharity"를 만들지 않을 것입니다. 각각의 추가 문자는 58의 요인으로 난이도를 증가시킵니다. 7 개 이상의 문자를 가진 패턴은 대개 여러 개의 GPU가있는 맞춤형 데스크탑과 같은 특수 하드웨어에 의해 발견됩니다. 이들은 종종 비트 코닝 광산업에서 더 이상 수익성이 없지만 허영심 주소를 찾는 데 사용될 수있는 용도가 바뀐 비트 코닝 광산 "굴착 장치"입니다. GPU 시스템에서 허영성 검색은 범용 CPU보다 훨씬 빠르게 진행됩니다.

허영심 주소를 찾는 또 다른 방법은 http://vanitypool.appspot.com [Vanity Pool]에있는 풀과 같은 허영 광부 풀에 작업을 아웃소싱하는 것입니다. 풀은 GPU 하드웨어를 사용하는 사람들이 다른 사용자의 가상 어드레스를 검색하는 비트 코인을 얻을 수있게 해주는 서비스입니다. 적은 금액 (0.01 비트 코인 또는이 글을 쓰는 시점의 약 5 달러)의 경우, Eugenia는 7 자 패턴의 허영 주소에 대한 검색을 아웃소싱하고 몇 달 동안 CPU 검색을 실행하지 않고 몇 시간 만에 결과를 얻을 수 있습니다.

허영 주소 생성은 무차별 대입 연습입니다. 임의의 키를 사용하여 결과 주소를 확인하여 원하는 패턴과 일치하는지 확인하고 성공할 때까지 반복하십시오. << vanity_miner_code >>는 "허영 광부 (vanity miner)"의 예입니다.이 프로그램은 C ++로 작성된 허영심 주소를 찾는 프로그램입니다. 이 예제는 << alt_libraries >>에서 소개 한 libbitcoin 라이브러리를 사용합니다.

[[vanity_miner_code]]
.Vanity address miner
====
[source,cpp]
----
include::code/vanity-miner.cpp[]
----
====

[노트]
====
<< vanity_miner_run >>은 + std :: random_device +를 사용합니다. 구현에 따라 기본 운영 체제에서 제공하는 CSRNG를 반영 할 수 있습니다. 리눅스와 같은 유닉스 계열의 운영체제의 경우, + / dev / urandom +에서 가져온다. 여기에 사용 된 난수 생성기는 데모 용이며, 충분한 보안으로 구현되지 않아 제작 품질의 비트 동전 키를 생성하는 데 적합하지 않습니다.
====

예제 코드는 pass : [C ++] 컴파일러를 사용하여 컴파일해야하며 libbitcoin 라이브러리 (해당 시스템에 처음 설치해야 함)와 연결되어야합니다. 예제를 실행하려면 매개 변수없이 ++ vanity-miner ++ 실행 파일을 실행하십시오 (<< vanity_miner_run >> 참조). 그러면 "1kid"로 시작하는 가상 주소를 찾으려고 시도합니다.

[[vanity_miner_run]]
.Compiling and running the vanity-miner example
====
[source,bash]
----
$ # Compile the code with g++
$ g++ -o vanity-miner vanity-miner.cpp $(pkg-config --cflags --libs libbitcoin)
$ # Run the example
$ ./vanity-miner
Found vanity address! 1KiDzkG4MxmovZryZRj8tK81oQRhbZ46YT
Secret: 57cc268a05f83a23ac9d930bc8565bac4e277055f4794cbd1a39e5e71c038f3f
$ # Run it again for a different result
$ ./vanity-miner
Found vanity address! 1Kidxr3wsmMzzouwXibKfwTYs5Pau8TUFn
Secret: 7f65bbbbe6d8caae74a0c6a0d2d7b5c6663d71b60337299a1a2cf34c04b2a623
# Use "time" to see how long it takes to find a result
$ time ./vanity-miner
Found vanity address! 1KidPWhKgGRQWD5PP5TAnGfDyfWp5yceXM
Secret: 2a802e7a53d8aa237cd059377b616d2bfcfa4b0140bc85fa008f2d3d4b225349

real	0m8.868s
user	0m8.828s
sys	0m0.035s
----
====

예제 코드는 실행 시간을 측정하기 위해 + time + Unix 명령을 사용할 때 알 수 있듯이 3 자 패턴 "kid"에 대한 일치를 찾기 위해 몇 초가 걸릴 것입니다. 소스 코드에서 + 검색 + 패턴을 변경하고 4 자 또는 5 자 패턴에 소요되는 시간을 확인하십시오!

===== Vanity address security

((("security", "vanity addresses")))허영심 주소는 보안 조치를 무력화시키기 위해 사용할 수 있습니다. 그들은 진정으로 양날의 칼입니다. 고유 한 주소로 보안을 강화하기 위해 상대방이 자신의 주소를 대체하고 고객을 대신 속여 돈을 지불하는 것을 어렵게 만듭니다. 불행히도, 허영심 주소는 또한 누군가가 임의의 주소 또는 다른 가상 주소를 나타내는 주소를 작성하여 고객을 속일 수있게합니다.

Eugenia는 사람들이 기부금을 보낼 수있는 임의로 생성 된 주소 (예 : + 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy +)를 광고 할 수 있습니다. 또는 그녀는 1Kids로 시작하는 허영심 주소를 생성하여 더 눈에 잘 띄게 할 수 있습니다.

두 경우 모두 기증자 당 별도의 동적 주소가 아닌 단일 고정 주소 사용의 위험 중 하나는 도둑이 귀하의 웹 사이트에 침투하여이를 자신의 주소로 대체함으로써 기부금을 자신에게 돌릴 수 있다는 것입니다. 기부 주소를 여러 곳에서 광고하는 경우 사용자는 지불하기 전에 주소를 시각적으로 조사하여 웹 사이트, 이메일 및 전단지에서 본 것과 동일한 주소인지 확인하십시오. + 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy +와 같은 임의의 주소의 경우 일반 사용자는 처음 몇 자의 "1J7mdg"를 검사하여 주소가 일치하는지 확인합니다. 세면대 주소 생성기를 사용하여 유사하게 보이는 주소를 대체하여 도용하려는 의도는 << table_4-13 >>에 표시된 것처럼 처음 몇 문자와 일치하는 주소를 신속하게 생성 할 수 있습니다.

[[table_4-13]]
.Generating vanity addresses to match a random address
|=======
| *Original Random Address* | 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
| *Vanity (4-character match)* | 1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy
| *Vanity (5-character match)* | 1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n
| *Vanity (6-character match)* | 1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX
|=======

허영심의 주소가 보안을 강화합니까? Eugenia가 가상 주소 + 1Kids33q44erFfpeXrmDSz7zEqG2FesZEN +을 생성하면 사용자는 주소의 "1Kids33"부분을 인식하는 등 세면대 패턴 단어 _와 몇 문자 이상을 볼 수 있습니다. 이로 인해 공격자는 최소한 6 자 (2 개 이상)와 일치하는 허영심 주소를 생성하고 강제로 3,664 번 (58 & # x00D7; 58)의 노력을 Eugenia가 4 문자 가상 장치에 소비 한 노력보다 더 많이 소비하게 만듭니다. 본질적으로, Eugenia가 소비하는 노력 (또는 허영을위한 돈을 지불하는)은 공격자가 더 긴 패턴의 허영을 만들어야하는 것을 "밀어 낸다". Eugenia가 8 자리 가상 주소를 생성하기 위해 풀을 지불하면 침입자는 개인용 컴퓨터에서 실행할 수없고 맞춤식 세면대 또는 세면대 풀을 사용하여도 값 비싼 10 자 영역으로 푸시됩니다. Eugenia의 경우 저렴한 가격은 공격자에게 부적합합니다. 특히 사기의 잠재적 보상이 허영 주소 생성 비용을 충당 할만큼 충분히 높지 않은 경우에는 더욱 그렇습니다.((("", startref="Avanity04")))((("", startref="vanity04")))((("", startref="eugeniafour"))) 

[[paper_wallets]]
==== Paper Wallets

((("keys and addresses", "advanced forms", "paper wallets")))((("paper wallets", id="paperw04")))((("wallets", "types of", "paper wallets", id="Wpaper04")))종이 지갑은 종이에 인쇄 된 비트 코 개인 키입니다. 종종 종이 지갑에는 편의를 위해 해당 비트 코인 주소도 포함되지만 개인 키에서 파생 될 수 있기 때문에 필요하지 않습니다. 종이 지갑은 "콜드 스토리지 (cold storage)"라고도하는 백업 또는 오프라인 비트 코인 저장소를 만드는 매우 효과적인 방법입니다. 백업 메커니즘으로 종이 지갑은 하드 드라이브 고장, 도난 또는 실수로 인한 삭제와 같은 컴퓨터 사고로 인한 키 손실에 대한 보안을 제공 할 수 있습니다. "콜드 스토리지"메커니즘으로, 종이 지갑 키가 오프라인으로 생성되어 컴퓨터 시스템에 저장되지 않으면 해커, 키로거 및 기타 온라인 컴퓨터 위협으로부터 훨씬 안전합니다.

종이 지갑은 다양한 모양, 크기 및 디자인으로 제공되지만 매우 기본적인 수준에서는 종이에 인쇄 된 주소와 주소 일뿐입니다. << table_4-14 >>는 가장 간단한 형태의 종이 지갑을 보여줍니다.

[[table_4-14]]
.Simplest form of a paper wallet—a printout of the bitcoin address and private key
[options="header"]
|=======================
|Public address|Private key (WIF)
|1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x|5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
|=======================


_bitaddress.org_에서 클라이언트 측 JavaScript 생성기와 같은 도구를 사용하여 종이 지갑을 쉽게 생성 할 수 있습니다. 이 페이지에는 인터넷에서 완전히 분리 된 상태에서도 키와 지폐를 생성하는 데 필요한 모든 코드가 들어 있습니다. 이 파일을 사용하려면 HTML 페이지를 로컬 드라이브 나 외부 USB 플래시 드라이브에 저장하십시오. 인터넷에서 연결을 끊고 브라우저에서 파일을 엽니 다. CD-ROM으로 부팅 가능한 Linux OS와 같은 초기 운영 체제를 사용하여 컴퓨터를 부팅하는 것이 더 좋습니다. 오프라인 상태에서이 도구로 생성 된 키는 USB 케이블 (무선이 아님)을 통해 로컬 프린터에서 인쇄 할 수 있으므로 키가 종이에만 존재하고 온라인 시스템에는 저장되지 않은 페이퍼 지갑을 만들 수 있습니다. 이 종이 지갑을 내화 금고에 넣어 간단하면서도 효과적인 "저온 저장"솔루션을 구현하기 위해 비트 코인 주소에 비트 코닉을 보냅니다. << paper_wallet_simple >>은 bitaddress.org 사이트에서 생성 된 종이 지갑을 표시합니다.

[[paper_wallet_simple]]
.An example of a simple paper wallet from bitaddress.org
image::images/mbc2_0408.png[]

((("bitcoin improvement proposals", "Encrypted Private Keys (BIP-38)")))종이에 접근 할 수있는 도둑은 그것을 훔치거나 키를 촬영하고 그 키로 잠긴 비트 코인을 제어 할 수 있습니다. 보다 정교한 종이 지갑 보관 시스템은 BIP-38 암호화 된 개인 키를 사용합니다. 종이 지갑에 인쇄 된 키는 소유자가 암기 한 암호 문구로 보호됩니다. 암호문이 없으면 암호화 된 키는 쓸모가 없습니다. 그러나 키가 온라인 상태가 아니므로 안전하거나 다른 물리적으로 안전한 저장소에서 물리적으로 검색해야하기 때문에 암호 보호 지갑보다 우월합니다. << paper_wallet_encrypted >>는 bitaddress.org 사이트에서 암호화 된 개인 키 (BIP-38)가있는 종이 지갑을 표시합니다.

[[paper_wallet_encrypted]]
.An example of an encrypted paper wallet from bitaddress.org. The passphrase is "test."
image::images/mbc2_0409.png[]

[주의]
====
종이 지갑에 여러 번 돈을 예치 할 수 있지만, 모든 것을 쓰면 모든 자금을 한 번만 인출해야합니다. 이는 잠금 해제 및 자금 지출 과정에서 전체 금액보다 적은 금액을 지출하는 경우 일부 지갑에서 변경 주소를 생성 할 수 있기 때문입니다. 또한 트랜잭션 서명에 사용하는 컴퓨터가 손상되면 개인 키가 노출 될 위험이 있습니다. 종이 지갑의 전체 잔액을 한 번만 사용하면 주요 손상 위험을 줄일 수 있습니다. 적은 금액 만 필요한 경우 남은 금액을 동일한 거래의 새 지폐로 보내십시오.
====

종이 지갑은 여러 가지 다양한 디자인과 크기로 제공됩니다. 일부는 선물로 주어지며 크리스마스 나 새해 같은 계절 테마가 있습니다. 다른 것들은 은행 금고 나 금고에 저장하도록 설계되었거나, 불투명 스크래치 스티커가있는 개인 키가 숨겨져 있거나, 변조 방지 접착 호일로 접혀서 봉인되었습니다. 수치는 다음을 통과합니다. [<data-type = "xref"href] [<a data-type="xref" href="#paper_wallet_bpw" data-xrefstyle="select: labelnumber"> #paper_wallet_bpw </a>] = "# paper_wallet_spw"data-xrefstyle = "select : labelnumber"> # paper_wallet_spw </a>] 보안 및 백업 기능이있는 다양한 종이 지갑의 예를 보여줍니다.

[[paper_wallet_bpw]]
.An example of a paper wallet from bitcoinpaperwallet.com with the private key on a folding flap
image::images/mbc2_0410.png[]

[[paper_wallet_bpw_folded]]
.The bitcoinpaperwallet.com paper wallet with the private key concealed
image::images/mbc2_0411.png[]

Other designs feature additional copies of the key and address, in the form of detachable stubs similar to ticket stubs, allowing you to store multiple copies to protect against fire, flood, or other natural disasters.((("", startref="KAadvanced04")))((("", startref="Wpaper04")))((("", startref="paperw04"))) 

[[paper_wallet_spw]]
.An example of a paper wallet with additional copies of the keys on a backup "stub"
image::images/mbc2_0412.png[]




